<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RAG-Demo - Ambiente Educacional</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Socket.IO -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    
    <!-- Marked.js para renderização de Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Highlight.js para syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <style>
        /* Reset básico para evitar margens e paddings desnecessários */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        
        /* Animações e estilos customizados */
        .chat-message {
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .loading-dots {
            animation: loading 1.5s infinite;
        }
        
        @keyframes loading {
            0%, 20% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        .markdown-content {
            line-height: 1.6;
        }
        
        /* Dynamic Slider Styles */
        .dynamic-slider {
            background: linear-gradient(to right, #9ca3af 0%, #9ca3af 100%);
            outline: none;
            transition: background 0.3s ease;
        }
        
        .dynamic-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .dynamic-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .dynamic-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .dynamic-slider::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .markdown-content p {
            margin-bottom: 1rem;
        }
        
        .markdown-content code {
            background-color: #f3f4f6;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
        }
        
        .markdown-content pre {
            background-color: #1f2937;
            color: #f9fafb;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 1rem 0;
        }
        
        /* Estilos para o menu lateral */
        .sidebar-item {
            transition: all 0.2s ease;
        }
        
        .sidebar-item:hover {
            background-color: #f3f4f6;
        }
        
        .sidebar-item.active {
            background-color: #dbeafe;
            color: #1d4ed8;
            border-right: 3px solid #1d4ed8;
        }
        
        /* Estilos para a barra de similaridade */
        .slider {
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, #3b82f6 0%, #3b82f6 0%, #e5e7eb 0%);
            border-radius: 8px;
            outline: none;
        }
        
        /* Estilos para layout de altura fixa */
        .main-container {
            height: 100vh; /* Usar toda a altura da tela */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        /* Garantir que o header não ocupe espaço desnecessário */
        .main-container header {
            flex-shrink: 0;
        }
        
        /* Garantir que o conteúdo principal use o espaço restante */
        .main-container > div:last-child {
            flex: 1;
            overflow: auto;
        }
        
        .semantic-layout {
            height: calc(100vh - 80px); /* Subtrair altura do header */
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        .semantic-chat-area {
            flex: 1;
            min-height: 0; /* Importante para flexbox funcionar */
            display: flex;
            flex-direction: column;
            height: calc(100vh - 120px); /* 80px header + 40px padding/margins */
            overflow: hidden;
        }
        
        /* Garantir que o semantic-messages use toda a altura disponível */
        .semantic-chat-area #semantic-messages {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            overflow-x: hidden;
            max-height: none;
        }
        
        /* Garantir que o header do chat seja fixo */
        .semantic-chat-area > div:first-child {
            flex-shrink: 0;
            min-height: auto;
        }
        
        /* Garantir que o input seja fixo */
        .semantic-chat-area > div:last-child {
            flex-shrink: 0;
            min-height: auto;
        }
        
        /* Garantir que o semantic-content use toda a altura sem rolagem */
        #semantic-content:not(.hidden) {
            height: calc(100vh - 120px) !important; /* 80px header + 40px padding/margins */
            max-height: calc(100vh - 120px) !important;
            overflow: hidden !important;
        }
        
        /* Garantir que o content-section não adicione margens */
        #semantic-content.content-section:not(.hidden) {
            margin: 0 !important;
            padding: 0 !important;
            height: 100% !important;
            display: flex !important;
            flex-direction: column !important;
        }
        
        /* Apenas o semantic-messages deve ter rolagem */
        #semantic-messages {
            flex: 1 !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            min-height: 0 !important;
            max-height: none !important;
            height: auto !important;
        }
        
        /* Garantir que o semantic-chat-area use flexbox corretamente */
        #semantic-content:not(.hidden) .semantic-chat-area {
            display: flex !important;
            flex-direction: column !important;
            height: 100% !important;
            overflow: hidden !important;
        }
        
        /* Garantir que o header e input sejam fixos */
        .semantic-chat-area > div:first-child,
        .semantic-chat-area > div:last-child {
            flex-shrink: 0 !important;
        }
        
        /* Forçar layout lado a lado para collections e modelos */
        .semantic-layout-row {
            display: flex !important;
            flex-direction: row !important;
            gap: 1rem !important;
            width: 100% !important;
            max-width: 100% !important;
            overflow: visible !important;
        }
        
        .semantic-layout-col {
            flex: 1 1 0% !important;
            min-width: 0 !important;
            width: 50% !important;
            max-width: 50% !important;
            float: none !important;
            clear: none !important;
            display: block !important;
        }
        
        /* Sobrescrever qualquer regra que force display block */
        #semantic-content .semantic-layout-row > div {
            display: block !important;
            float: none !important;
            clear: none !important;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        /* Layout responsivo */
        @media (max-width: 768px) {
            .semantic-layout {
                height: calc(100vh - 120px);
                margin: 0;
                padding: 0.5rem;
            }
            
            .semantic-chat-area {
                height: calc(100vh - 120px - 1rem);
            }
            
            #semantic-messages {
                min-height: 0 !important;
                max-height: none !important;
            }
            
            .semantic-layout-row {
                flex-direction: column !important;
                gap: 0.5rem !important;
            }
            
            .semantic-layout-col {
                width: 100% !important;
                max-width: 100% !important;
            }
            .sidebar {
                transform: translateX(-100%);
                position: fixed;
                z-index: 50;
                transition: transform 0.3s ease;
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .main-content {
                margin-left: 0;
            }
            
            .mobile-menu-toggle {
                display: block;
            }
            
            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 40;
            }
            
            .sidebar-overlay.open {
                display: block;
            }
        }
        
        /* Esconder toggle mobile em desktop */
        .mobile-menu-toggle {
            display: none;
        }
        
        /* Estilos para upload de arquivo */
        .upload-zone-active {
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
        }
        
        .file-preview-enter {
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Estilos para drag and drop */
        .upload-zone.dragover {
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
            transform: scale(1.02);
        }
        
        .upload-zone.dragover .upload-placeholder {
            transform: scale(1.05);
        }
        
        /* Animação de hover para elementos decorativos */
        .upload-zone:hover .absolute.opacity-5 > div {
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        
        /* Estilo para o botão de seleção de arquivo */
        .file-input-label {
            transition: all 0.2s ease;
        }
        
        .file-input-label:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Layout Principal com Menu Lateral -->
    <div class="flex h-screen">
        <!-- Overlay para mobile -->
        <div id="sidebar-overlay" class="sidebar-overlay"></div>
        
        <!-- Menu Lateral Fixo -->
        <aside class="sidebar w-64 bg-white shadow-lg border-r border-gray-200 flex-shrink-0 flex flex-col">
            <!-- Logo/Header do Sidebar -->
            <div class="p-6 border-b border-gray-200">
                    <h1 class="text-xl font-semibold text-gray-900">
                    RAG-Demo
                    </h1>
                <p class="text-sm text-gray-600 mt-1">Ambiente Educacional</p>
                </div>
            
            <!-- Menu de Navegação -->
            <nav class="flex-1 p-4 space-y-2">
                <button id="upload-nav" class="sidebar-item active w-full flex items-center space-x-3 px-4 py-3 rounded-lg text-left">
                    <i data-lucide="upload" class="w-5 h-5"></i>
                    <span>Upload</span>
                    </button>
                
                <button id="collections-nav" class="sidebar-item w-full flex items-center space-x-3 px-4 py-3 rounded-lg text-left">
                    <i data-lucide="folder-open" class="w-5 h-5"></i>
                    <span>Collections</span>
                    </button>
                
                <button id="editor-nav" class="sidebar-item w-full flex items-center space-x-3 px-4 py-3 rounded-lg text-left">
                    <i data-lucide="edit-3" class="w-5 h-5"></i>
                    <span>Editor</span>
                    </button>
                
                                <button id="chat-nav" class="sidebar-item w-full flex items-center space-x-3 px-4 py-3 rounded-lg text-left">
                    <i data-lucide="search" class="w-5 h-5"></i>
                    <span>Busca por Similaridade</span>
                </button>
                
                <button id="semantic-nav" class="sidebar-item w-full flex items-center space-x-3 px-4 py-3 rounded-lg text-left">
                    <i data-lucide="brain" class="w-5 h-5"></i>
                    <span>Chat Multi-Agente</span>
                </button>
                
                <button id="semantic-search-nav" class="sidebar-item w-full flex items-center space-x-3 px-4 py-3 rounded-lg text-left">
                    <i data-lucide="zap" class="w-5 h-5"></i>
                    <span>Busca Semântica</span>
                </button>
                
                <button id="history-nav" class="sidebar-item w-full flex items-center space-x-3 px-4 py-3 rounded-lg text-left">
                    <i data-lucide="clock" class="w-5 h-5"></i>
                    <span>Histórico</span>
                    </button>
            </nav>
            
            <!-- Status de Conexão -->
            <div class="mt-auto">
                <div id="status-indicator" class="flex items-center space-x-2 p-3 bg-gray-50 rounded-lg">
                    <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                    <span class="text-sm text-gray-600">Conectado</span>
                </div>
            </div>
        </aside>

        <!-- Área de Trabalho Principal -->
        <main class="main-content flex-1 flex flex-col ml-0 lg:ml-0 main-container">
                        <!-- Cabeçalho -->
            <header class="bg-white shadow-sm border-b border-gray-200 px-6 py-4">
                <div class="flex justify-between items-center">
                    <!-- Mobile menu toggle -->
                    <button id="mobile-menu-toggle" class="mobile-menu-toggle lg:hidden p-2 rounded-md text-gray-600 hover:text-gray-900 hover:bg-gray-100">
                        <i data-lucide="menu" class="w-6 h-6"></i>
                    </button>
                    
                    <div>
                        <h2 id="page-title" class="text-xl font-semibold text-gray-900">Upload de Documento</h2>
                        <p id="page-subtitle" class="text-sm text-gray-600">Faça upload de documentos para processamento</p>
                    </div>
                    
                    <!-- Status de Vetorização -->
                        <div class="flex items-center space-x-2">
                            <span class="text-sm font-medium text-gray-700">Status:</span>
                            <div id="vectorization-status" class="text-sm text-gray-600">
                                <div class="flex items-center space-x-2">
                                    <div class="w-2 h-2 bg-gray-400 rounded-full"></div>
                                    <span>Aguardando...</span>
                                </div>
                            </div>
                        </div>
                            </div>
            </header>
                    
            <!-- Conteúdo Principal -->
            <div class="flex-1 overflow-auto p-6">
                <!-- Tela de Upload -->
                <div id="upload-content" class="content-section">
                    <div class="bg-white rounded-lg shadow p-6">
                        <div class="space-y-6">
                            <!-- File Upload -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">
                                    Selecione um arquivo PDF, DOCX, TXT ou MD
                                </label>
                                <div id="upload-zone" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center transition-all duration-200 hover:border-blue-400 hover:bg-blue-50 relative overflow-hidden">
                                    <!-- Background decoration -->
                                    <div class="absolute inset-0 opacity-5">
                                        <div class="absolute top-4 left-4 w-16 h-16 bg-blue-500 rounded-full"></div>
                                        <div class="absolute bottom-4 right-4 w-12 h-12 bg-green-500 rounded-full"></div>
                                        <div class="absolute top-1/2 left-1/4 w-8 h-8 bg-purple-500 rounded-full"></div>
                                        <div class="absolute top-1/3 right-1/3 w-10 h-10 bg-yellow-500 rounded-full"></div>
                                    </div>
                                    
                                    <input type="file" id="file-input" class="hidden" accept=".pdf,.docx,.txt,.md">
                                    <div id="upload-placeholder" class="space-y-4 relative z-10">
                                        <div class="flex flex-col items-center space-y-3">
                                            <div class="relative">
                                                <i data-lucide="upload-cloud" class="mx-auto h-16 w-16 text-gray-400"></i>
                                                <div class="absolute -bottom-1 -right-1 w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center">
                                                    <i data-lucide="plus" class="w-3 h-3 text-white"></i>
                                                </div>
                                            </div>
                                            <div class="text-center space-y-2">
                                                <label for="file-input" class="file-input-label relative cursor-pointer bg-blue-600 text-white px-6 py-3 rounded-lg font-medium hover:bg-blue-700 transition-colors inline-flex items-center space-x-2">
                                                    <i data-lucide="file-plus" class="w-4 h-4"></i>
                                                    <span>Selecionar arquivo</span>
                                                </label>
                                                <p class="text-sm text-gray-500">ou arraste e solte aqui</p>
                                                <p class="text-xs text-gray-400">PDF, DOCX, TXT ou MD (máx. 10MB)</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div id="file-preview" class="hidden relative z-10">
                                        <div class="flex items-center justify-between p-6 bg-white rounded-lg border border-gray-200 shadow-sm">
                                            <div class="flex items-center space-x-4">
                                                <div class="flex-shrink-0">
                                                    <div class="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center">
                                                        <i data-lucide="file-text" class="h-6 w-6 text-blue-600"></i>
                                                    </div>
                                                </div>
                                                <div class="flex-1 min-w-0">
                                                    <div id="file-name" class="text-sm font-semibold text-gray-900 truncate"></div>
                                                    <div id="file-size" class="text-xs text-gray-500 mt-1"></div>
                                                    <div class="flex items-center space-x-2 mt-2">
                                                        <div class="w-full bg-gray-200 rounded-full h-1">
                                                            <div class="bg-blue-600 h-1 rounded-full" style="width: 100%"></div>
                                                        </div>
                                                        <span class="text-xs text-green-600 font-medium">Pronto</span>
                                                    </div>
                                                </div>
                                            </div>
                                            <button id="remove-file" class="flex-shrink-0 p-2 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-full transition-colors">
                                                <i data-lucide="x" class="h-5 w-5"></i>
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                <div id="file-info" class="mt-2 text-sm text-gray-600 hidden"></div>
                                
                                <!-- Lista de arquivos preparados para processamento -->
                                <div id="files-queue" class="hidden mt-4">
                                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                        <div class="flex items-center space-x-2 mb-3">
                                            <i data-lucide="clock" class="w-5 h-5 text-blue-600"></i>
                                            <h4 class="text-sm font-semibold text-blue-800">Arquivos Preparados para Processamento</h4>
                                        </div>
                                        <div id="files-list" class="space-y-2">
                                            <!-- Arquivos serão adicionados dinamicamente aqui -->
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Collection Selection and LLM Enhancement -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Collection:</label>
                                    <select id="upload-collection-select" class="w-full border border-gray-300 rounded-md px-3 py-2">
                                        <option value="">Carregando collections...</option>
                                    </select>
                                    <p class="text-xs text-gray-500 mt-1">Selecione a collection para armazenar os documentos</p>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Melhorar com LLM:</label>
                                    <select id="upload-enhance" class="w-full border border-gray-300 rounded-md px-3 py-2">
                                        <option value="true">Sim</option>
                                        <option value="false">Não</option>
                                    </select>
                                    <p class="text-xs text-gray-500 mt-1">Usa LLM para melhorar o conteúdo</p>
                                </div>
                            </div>

                            <!-- Action Buttons -->
                            <div class="grid grid-cols-2 gap-3 mb-3">
                                <button id="charset-test-btn" class="bg-orange-500 text-white px-3 py-1.5 rounded-md hover:bg-orange-600 disabled:opacity-50 disabled:cursor-not-allowed text-sm">
                                    🧪 Testar Charset
                                </button>
                                <button id="upload-btn" class="bg-blue-600 text-white px-3 py-1.5 rounded-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed text-sm">
                                    📊 Processar Documento
                                </button>
                            </div>

                            <!-- Charset Test Results -->
                            <div id="charset-test-results" class="hidden mb-4">
                                <div class="bg-gray-50 rounded-lg p-4 border border-gray-200">
                                    <h4 class="text-sm font-semibold text-gray-800 mb-2">📊 Resultado do Teste de Charset</h4>
                                    <div id="charset-test-content"></div>
                                </div>
                            </div>

                            <!-- Progress -->
                            <div id="upload-progress" class="hidden">
                                <div class="bg-gray-100 rounded-lg p-4 border border-gray-200">
                                    <div class="flex items-center space-x-3 mb-3">
                                        <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
                                        <span class="text-sm font-medium text-gray-700">Processando documento...</span>
                                    </div>
                                    <div class="bg-gray-200 rounded-full h-2">
                                        <div id="default-progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                    </div>
                                    <div id="default-progress-text" class="text-sm text-gray-600 mt-2">Iniciando processamento...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>



                <!-- Dashboard de Collections -->
                <div id="collections-content" class="content-section hidden">
                    <div class="bg-white rounded-lg shadow p-6">
                        <div class="mb-6">
                            <h2 class="text-2xl font-bold text-gray-900">Collections</h2>
                        </div>
                        
                        <!-- Filters and Actions -->
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Filtro por Modelo:</label>
                                <select id="model-filter" class="w-full border border-gray-300 rounded-md px-3 py-2">
                                    <option value="">Todos os modelos</option>
                                </select>
                                <p class="text-xs text-gray-500 mt-1">Filtrar por modelo de embedding</p>
                            </div>

                            <div class="flex items-end">
                                <button id="new-collection-btn" class="w-full bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700">
                                    Nova Collection
                                </button>
                            </div>
                        </div>
                        
                        <!-- Lista de Collections -->
                        <div id="collections-list" class="space-y-4">
                            <!-- Collections serão carregadas aqui -->
                        </div>
                    </div>
                </div>

                <!-- Editor de Conteúdo -->
                <div id="editor-content" class="content-section hidden">
                    <div class="bg-white rounded-lg shadow p-6">
                        <h2 class="text-2xl font-bold text-gray-900 mb-6">Editor de Perguntas e Respostas</h2>
                        
                        <div class="space-y-6">
                            <!-- Document Selection -->
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Collection (Origem):</label>
                                    <select id="editor-collection-select" class="w-full border border-gray-300 rounded-md px-3 py-2" required>
                                        <option value="">Selecione uma collection...</option>
                                    </select>
                                    <p class="text-xs text-gray-500 mt-1">Collection com documentos originais</p>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-1">Documento:</label>
                                    <select id="editor-document-select" class="w-full border border-gray-300 rounded-md px-3 py-2" required>
                                        <option value="">Selecione um documento...</option>
                                    </select>
                                    <p class="text-xs text-gray-500 mt-1">Documento para gerar Q&As</p>
                                </div>
                            </div>

                            <!-- Document Info -->
                            <div id="document-info" class="hidden">
                                <h3 class="text-lg font-medium text-gray-900 mb-3">📊 Métricas do Documento</h3>
                                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    <div class="bg-gray-50 p-3 rounded-lg">
                                        <div class="text-2xl font-bold text-blue-600" id="char-count">0</div>
                                        <div class="text-sm text-gray-600">Caracteres</div>
                                    </div>
                                    <div class="bg-gray-50 p-3 rounded-lg">
                                        <div class="text-2xl font-bold text-green-600" id="word-count">0</div>
                                        <div class="text-sm text-gray-600">Palavras</div>
                                    </div>
                                    <div class="bg-gray-50 p-3 rounded-lg">
                                        <div class="text-2xl font-bold text-purple-600" id="unique-words">0</div>
                                        <div class="text-sm text-gray-600">Palavras Únicas</div>
                                    </div>
                                    <div class="bg-gray-50 p-3 rounded-lg">
                                        <div class="text-2xl font-bold text-orange-600" id="avg-word-length">0</div>
                                        <div class="text-sm text-gray-600">Tamanho Médio</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Q&A Generation Parameters -->
                            <div class="bg-gray-50 p-4 rounded-lg">
                                <h3 class="text-lg font-medium text-gray-900 mb-3">⚙️ Configurações de Geração</h3>
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Número de Q&As:</label>
                                        <input type="number" id="num-questions" min="1" max="500" value="50" class="w-full border border-gray-300 rounded-md px-3 py-2">
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Dificuldade:</label>
                                        <select id="difficulty" class="w-full border border-gray-300 rounded-md px-3 py-2">
                                            <option value="Iniciante">Iniciante</option>
                                            <option value="Intermediário" selected>Intermediário</option>
                                            <option value="Avançado">Avançado</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Criatividade:</label>
                                        <input type="range" id="temperature" min="0.0" max="1.0" step="0.1" value="0.5" class="w-full">
                                        <div class="text-xs text-gray-500 mt-1" id="temperature-value">0.5</div>
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-700 mb-1">Palavras-chave:</label>
                                        <input type="text" id="context-keywords" class="w-full border border-gray-300 rounded-md px-3 py-2" placeholder="termo1, termo2, termo3">
                                        <p class="text-xs text-gray-500 mt-1">Separadas por vírgula</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Custom Prompt -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Instruções para geração:</label>
                                <textarea id="custom-prompt" rows="6" class="w-full border border-gray-300 rounded-md px-3 py-2 font-mono text-sm" placeholder="Instruções personalizadas para geração de Q&A...">Você é um especialista em criação de conteúdos educacionais. 
Gere no mínimo {num_questions} perguntas e respostas baseadas no documento abaixo:

REGRAS:
1. Foco nos contextos: {context_keywords} (priorizar estes termos)
2. Formato obrigatório: 
**Pergunta {{número}}:** [texto] \n\n **Resposta {{número}}:** [texto]
3. Nível de detalhe: adequado para profissionais de nível {difficulty}
4. Inclua exemplos quando relevante

DOCUMENTO:
{document_text}</textarea>
                            </div>

                            <!-- Action Buttons -->
                            <div class="flex flex-wrap gap-4">
                                <button id="generate-qa-btn" class="bg-green-600 text-white px-6 py-3 rounded-md hover:bg-green-700 font-medium">
                                    🚀 Gerar Q&As
                                </button>
                                <button id="vectorize-qa-btn" class="bg-blue-600 text-white px-6 py-3 rounded-md hover:bg-blue-700 font-medium hidden">
                                    📊 Vetorizar Q&As
                                </button>
                                <button id="edit-qa-btn" class="bg-yellow-600 text-white px-6 py-3 rounded-md hover:bg-yellow-700 font-medium hidden">
                                    ✏️ Editar Q&As
                                </button>
                            </div>

                            <!-- Progress Section -->
                            <div id="qa-progress" class="hidden">
                                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                    <div class="flex items-center space-x-3">
                                        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
                                        <div>
                                            <div class="text-sm font-medium text-blue-900" id="progress-status">Processando...</div>
                                            <div class="text-xs text-blue-700" id="progress-details">Iniciando geração de Q&As...</div>
                                        </div>
                                    </div>
                                    <div class="mt-3">
                                        <div class="w-full bg-blue-200 rounded-full h-2">
                                            <div id="qa-progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Generated Q&A Results -->
                            <div id="qa-results" class="hidden">
                                <div class="border-t pt-6">
                                    <div class="flex justify-between items-center mb-4">
                                        <h3 class="text-lg font-medium text-gray-900">📋 Q&As Gerados - Preview</h3>
                                        <div class="flex space-x-2">
                                            <button id="download-qa-btn" class="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 text-sm">
                                                💾 Baixar Q&As
                                            </button>
                                        </div>
                                    </div>
                                    
                                    <!-- Alerta de preview -->
                                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
                                        <div class="flex items-center space-x-2">
                                            <div class="text-yellow-600">⚠️</div>
                                            <div>
                                                <p class="text-sm font-medium text-yellow-800">Preview do Conteúdo Gerado</p>
                                                <p class="text-xs text-yellow-700">Revise o conteúdo antes de vetorizar. Você pode editar o markdown se necessário.</p>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <!-- Tabs para visualização -->
                                    <div class="mb-4">
                                        <div class="border-b border-gray-200">
                                            <nav class="-mb-px flex space-x-8">
                                                <button id="qa-tab-formatted" class="qa-tab-btn border-indigo-500 text-indigo-600 whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm" data-tab="formatted">
                                                    👁️ Preview Formatado
                                                </button>
                                                <button id="qa-tab-markdown" class="qa-tab-btn border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm" data-tab="markdown">
                                                    ✏️ Editar Markdown
                                                </button>
                                            </nav>
                                        </div>
                                    </div>
                                    
                                    <!-- Conteúdo formatado (preview) -->
                                    <div id="qa-content-formatted" class="qa-tab-content">
                                        <div id="qa-list" class="space-y-4 max-h-96 overflow-y-auto border border-gray-200 rounded-lg p-4 bg-white"></div>
                                    </div>
                                    
                                    <!-- Conteúdo markdown editável -->
                                    <div id="qa-content-markdown" class="qa-tab-content hidden">
                                        <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                                            <div class="flex justify-between items-center mb-2">
                                                <span class="text-sm font-medium text-gray-700">Markdown Editável:</span>
                                                <div class="flex space-x-2">
                                                    <button id="copy-markdown-btn" class="bg-blue-600 text-white px-3 py-1 rounded text-xs hover:bg-blue-700">
                                                        📋 Copiar
                                                    </button>
                                                    <button id="save-markdown-btn" class="bg-green-600 text-white px-3 py-1 rounded text-xs hover:bg-green-700">
                                                        💾 Salvar Alterações
                                                    </button>
                                                </div>
                                            </div>
                                            <textarea id="qa-markdown-content" class="w-full h-96 font-mono text-sm border border-gray-300 rounded-md px-3 py-2" placeholder="O markdown gerado aparecerá aqui e pode ser editado..."></textarea>
                                        </div>
                                    </div>
                                    
                                    <!-- Seção de vetorização -->
                                    <div id="vectorization-section" class="border-t pt-4 mt-6">
                                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                                            <h4 class="text-lg font-medium text-blue-900 mb-3">🚀 Pronto para Vetorizar?</h4>
                                            <p class="text-sm text-blue-700 mb-4">
                                                O conteúdo será inserido na collection de destino selecionada como embeddings vetorizados.
                                            </p>
                                            
                                            <!-- Seletor de Collection Destino -->
                                            <div class="mb-4">
                                                <label class="block text-sm font-medium text-blue-800 mb-2">Collection de Destino:</label>
                                                <div class="grid grid-cols-1 md:grid-cols-3 gap-3 items-end">
                                                    <div class="md:col-span-2">
                                                        <select id="qa-collection-select" class="w-full border border-blue-300 rounded-md px-3 py-2 bg-white" required>
                                                            <option value="">Selecione a collection destino...</option>
                                                        </select>
                                                        <p class="text-xs text-blue-600 mt-1">Collection para inserir Q&As geradas</p>
                                                    </div>
                                                    <div class="flex space-x-2">
                                                        <button id="refresh-collections-btn" class="bg-gray-600 text-white px-3 py-2 rounded-md hover:bg-gray-700 text-sm">
                                                            🔄 Atualizar
                                                        </button>
                                                        <button id="vectorize-final-btn" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 font-medium disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>
                                                            📊 Vetorizar Q&As
                                                        </button>
                                                    </div>
                                                </div>
                                            </div>

                                            <!-- Progress Section para Vetorização (próxima ao botão) -->
                                            <div id="qa-vectorize-progress" class="hidden mt-4">
                                                <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                                                    <div class="flex items-center space-x-3">
                                                        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-green-600"></div>
                                                        <div>
                                                            <div class="text-sm font-medium text-green-900" id="vectorize-progress-status">Vetorizando...</div>
                                                            <div class="text-xs text-green-700" id="vectorize-progress-details">Preparando embeddings...</div>
                                                        </div>
                                                    </div>
                                                    <div class="mt-3">
                                                        <div class="w-full bg-green-200 rounded-full h-2">
                                                            <div id="qa-vectorize-progress-bar" class="bg-green-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>

                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Chat -->
                <div id="chat-content" class="content-section hidden">
                    <div class="bg-white rounded-lg shadow flex flex-col min-h-[600px]">
                        <!-- Search Header -->
                        <div class="border-b px-6 py-4">
                            <div class="flex justify-between items-center">
                                <h2 class="text-xl font-semibold text-gray-900">🔍 Busca por Similaridade</h2>
                            </div>
                            
                            <!-- Collection Selection -->
                            <div class="mt-4">
                                <label class="block text-sm font-medium text-gray-700 mb-1">Collection:</label>
                                <select id="chat-collection-select" class="w-full border border-gray-300 rounded-md px-3 py-2">
                                    <option value="">Todas as collections</option>
                                </select>
                                <p class="text-xs text-gray-500 mt-1">Filtrar por collection</p>
                            </div>
                            
                            <!-- Similarity Threshold Control -->
                            <div class="mt-4">
                                <label class="block text-sm font-medium text-gray-700 mb-1">
                                    Similaridade Mínima: <span id="similarity-value" class="text-blue-600 font-bold">0%</span>
                                </label>
                                <input type="range" id="similarity-threshold" 
                                       min="0" max="100" value="0" step="5" 
                                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider">
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>0% (Mais resultados)</span>
                                    <span>100% (Mais precisos)</span>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">
                                    Ajuste o percentual mínimo de similaridade para filtrar resultados mais relevantes
                                </p>
                            </div>
                            
                            <!-- Search Input -->
                            <div class="mt-4">
                                <div class="flex space-x-4">
                                    <input type="text" id="chat-input" class="flex-1 border border-gray-300 rounded-md px-3 py-2" placeholder="Digite sua consulta para busca por similaridade...">
                                    <button id="send-message-btn" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700">
                                        Enviar
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Similarity Search Results -->
                        <div id="chat-messages" class="p-6 space-y-4">
                            <div class="text-center text-gray-500 text-sm">
                                Inicie uma busca por similaridade fazendo uma consulta...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Chat Multi-Agente -->
                <div id="semantic-content" class="content-section hidden semantic-layout">
                    <div class="bg-white rounded-lg shadow semantic-chat-area overflow-hidden">
                        <!-- Search Header (Fixed) -->
                        <div class="border-b px-6 py-3 flex-shrink-0">
                            <div class="flex justify-between items-center mb-2">
                                <h2 class="text-lg font-semibold text-gray-900">🤖 Chat Multi-Agente</h2>
                            </div>
                            
                            <!-- Session Selection -->
                            <div class="mb-3">
                                <div class="flex items-center space-x-2">
                                    <label class="text-sm font-medium text-gray-700">Sessão:</label>
                                    <select id="semantic-session-select" class="flex-1 border border-gray-300 rounded-md px-3 py-1 text-sm">
                                        <option value="">Nova sessão</option>
                                    </select>
                                    <button id="refresh-semantic-sessions-btn" class="px-2 py-1 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 transition-colors" title="Atualizar lista de sessões">
                                        <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                                    </button>
                                </div>
                                <div class="flex items-center justify-between mt-1">
                                    <span id="current-semantic-session-info" class="text-xs text-blue-600 font-medium hidden">
                                        Sessão ativa: <span id="current-semantic-session-name">-</span>
                                    </span>
                                </div>
                            </div>
                            
                            <!-- OpenAI and Gemini Side by Side with Dependent Collections -->
                            <div class="semantic-layout-row">
                                <!-- OpenAI Section -->
                                <div class="semantic-layout-col">
                                    <div class="border border-blue-200 rounded-lg p-2 bg-blue-50">
                                        <!-- OpenAI Model Header -->
                                        <div class="mb-2">
                                            <label class="flex items-center space-x-2 cursor-pointer">
                                                <input type="checkbox" id="openai-model-checkbox" class="rounded border-gray-300 text-blue-600 focus:ring-blue-500 w-3 h-3" checked>
                                                <span class="text-xs font-semibold text-blue-800">🤖 OpenAI GPT</span>
                                            </label>
                                        </div>
                                        
                                        <!-- OpenAI Collections -->
                                        <div class="ml-4">
                                            <label class="block text-xs font-medium text-blue-700 mb-1">Collections:</label>
                                            <div id="openai-collections" class="flex flex-wrap gap-1">
                                                <!-- OpenAI collections will be loaded here -->
                                                <div class="text-xs text-blue-500">Carregando...</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Gemini Section -->
                                <div class="semantic-layout-col">
                                    <div class="border border-green-200 rounded-lg p-2 bg-green-50">
                                        <!-- Gemini Model Header -->
                                        <div class="mb-2">
                                            <label class="flex items-center space-x-2 cursor-pointer">
                                                <input type="checkbox" id="gemini-model-checkbox" class="rounded border-gray-300 text-green-600 focus:ring-green-500 w-3 h-3" checked>
                                                <span class="text-xs font-semibold text-green-800">🤖 Google Gemini</span>
                                            </label>
                                        </div>
                                        
                                        <!-- Gemini Collections -->
                                        <div class="ml-4">
                                            <label class="block text-xs font-medium text-green-700 mb-1">Collections:</label>
                                            <div id="gemini-collections" class="flex flex-wrap gap-1">
                                                <!-- Gemini collections will be loaded here -->
                                                <div class="text-xs text-green-500">Carregando...</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Quick Actions -->
                            <div class="mt-2 text-center">
                                <button onclick="toggleAllModelsAndCollections()" class="text-xs text-purple-600 hover:text-purple-800 border border-purple-200 px-2 py-1 rounded-full bg-purple-50 hover:bg-purple-100 transition-colors">
                                    Selecionar todos os modelos
                                </button>
                            </div>
                        </div>

                        <!-- Semantic Search Results (Flexible Height with Scroll) -->
                        <div id="semantic-messages" class="flex-1 p-6 overflow-y-auto" style="min-height: 0; max-height: none; overflow-y: auto;">
                            <div class="text-center text-gray-500 text-sm">
                                💬 Faça uma pergunta para obter respostas dos modelos de IA selecionados...
                            </div>
                        </div>
                        
                        <!-- Search Input at Bottom (Fixed) -->
                        <div class="border-t px-6 py-3 flex-shrink-0 bg-white">
                            <div class="flex space-x-3">
                                <textarea id="semantic-input" rows="2" class="flex-1 border border-gray-300 rounded-lg px-4 py-2 resize-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500 text-sm" placeholder="Digite sua pergunta para o chat multi-agente..."></textarea>
                                <button id="send-semantic-btn" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 focus:ring-2 focus:ring-purple-500 self-end transition-colors duration-200">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="m22 2-7 20-4-9-9-4Z"/>
                                        <path d="M22 2 11 13"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Busca Semântica -->
                <div id="semantic-search-content" class="content-section hidden">
                    <div class="bg-white rounded-lg shadow overflow-hidden">
                        <!-- Header -->
                        <div class="border-b px-6 py-4">
                            <div class="flex justify-between items-center mb-4">
                                <h2 class="text-xl font-semibold text-gray-900">⚡ Busca Semântica por Modelo</h2>
                            </div>
                            
                            <!-- Model Selection -->
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-2">Modelo de IA:</label>
                                <div id="semantic-search-models" class="flex flex-wrap gap-2">
                                    <!-- Models will be loaded here -->
                                    <div class="text-xs text-gray-500">Carregando modelos...</div>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">Selecione o modelo de IA para busca e geração de resposta</p>
                            </div>
                            
                            <!-- Similarity Threshold Control -->
                            <div class="mb-4">
                                <label class="block text-sm font-medium text-gray-700 mb-1">
                                    Similaridade Mínima: <span id="semantic-similarity-value" class="text-indigo-600 font-bold">30%</span>
                                </label>
                                <input type="range" id="semantic-similarity-threshold" 
                                       min="10" max="80" value="30" step="5" 
                                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dynamic-slider">
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>10% (Mais permissivo)</span>
                                    <span>80% (Muito restritivo)</span>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">
                                    ⚠️ Busca semântica usa threshold mais alto para evitar respostas não baseadas na base de conhecimento
                                </p>
                            </div>
                            
                            <!-- Search Input -->
                            <div class="flex space-x-2">
                                <input type="text" id="semantic-search-input" class="flex-1 border border-gray-300 rounded-md px-3 py-2" placeholder="Digite sua pergunta para busca semântica...">
                                <button id="semantic-search-btn" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed">
                                    Buscar
                                </button>
                                <button id="debug-collections-btn" class="bg-gray-500 text-white px-3 py-2 rounded-md hover:bg-gray-600 text-sm">
                                    Debug
                                </button>
                                <button id="test-search-btn" class="bg-green-500 text-white px-3 py-2 rounded-md hover:bg-green-600 text-sm">
                                    Testar
                                </button>
                                <button id="test-gemini-btn" class="bg-purple-500 text-white px-3 py-2 rounded-md hover:bg-purple-600 text-sm">
                                    Test Gemini
                                </button>
                            </div>
                        </div>

                        <!-- Results -->
                        <div id="semantic-search-results" class="p-6">
                            <div class="text-center text-gray-500 text-sm">
                                Selecione um modelo e faça uma pergunta para obter uma resposta baseada nos documentos...
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Histórico -->
                <div id="history-content" class="content-section hidden">
                    <div class="bg-white rounded-lg shadow p-6">
                        <div class="flex justify-between items-center mb-6">
                            <h2 class="text-2xl font-bold text-gray-900">Histórico de Sessões</h2>
                            <button id="new-session-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors flex items-center gap-2">
                                <i data-lucide="plus" class="w-4 h-4"></i>
                                Nova Sessão
                            </button>
                        </div>
                        
                        <div id="sessions-list" class="space-y-4">
                            <!-- Sessões serão carregadas aqui -->
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

            <!-- Toast Notifications -->
        <div id="toast-container" class="fixed bottom-4 right-4 z-50 space-y-2"></div>

    <!-- Modal para Nova Collection -->
    <div id="collection-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden z-50">
        <div class="flex items-center justify-center min-h-screen p-4">
            <div class="bg-white rounded-lg shadow-xl max-w-md w-full">
                <div class="px-6 py-4 border-b">
                    <h3 class="text-lg font-medium text-gray-900">Nova Collection</h3>
                </div>
                
                <div class="px-6 py-4">
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Nome da Collection:</label>
                            <input type="text" id="collection-name-input" class="w-full border border-gray-300 rounded-md px-3 py-2" placeholder="ex: aula_pln_2024" required>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Descrição:</label>
                            <textarea id="collection-description-input" class="w-full border border-gray-300 rounded-md px-3 py-2" rows="2" placeholder="Descrição da collection..."></textarea>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">Modelo de Embedding:</label>
                            <select id="collection-embedding-model-select" class="w-full border border-gray-300 rounded-md px-3 py-2" required>
                                <option value="">Selecione um modelo...</option>
                            </select>
                            <p class="text-xs text-gray-500 mt-1">Modelo de embedding para esta collection</p>
                        </div>
                        
                        <div id="collection-model-info" class="hidden bg-blue-50 border border-blue-200 rounded-lg p-3">
                            <h4 class="text-sm font-medium text-blue-900 mb-2">Informações do Modelo</h4>
                            <div class="space-y-1 text-sm text-blue-800">
                                <div><span class="font-medium">Nome:</span> <span id="collection-model-name">-</span></div>
                                <div><span class="font-medium">Dimensão:</span> <span id="collection-model-dimension">-</span></div>
                                <div><span class="font-medium">Provider:</span> <span id="collection-model-provider">-</span></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="px-6 py-4 border-t flex justify-end space-x-3">
                    <button id="cancel-collection-btn" class="px-4 py-2 text-gray-600 hover:text-gray-800">
                        Cancelar
                    </button>
                    <button id="create-collection-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                        Criar Collection
                    </button>
                </div>
            </div>
        </div>
    </div>



    <!-- JavaScript -->
    <script>
        // Socket.IO connection
        const socket = io();
        
        // Debug: Socket connection events
        socket.on('connect', () => {
            console.log('✅ Socket conectado com sucesso! ID:', socket.id);
        });
        
        socket.on('disconnect', (reason) => {
            console.log('❌ Socket desconectado:', reason);
        });
        
        socket.on('connect_error', (error) => {
            console.log('❌ Erro na conexão do socket:', error);
        });
        
        // Debug: Listener global para upload_progress
        socket.on('upload_progress', (data) => {
            console.log('📺 LISTENER GLOBAL - Progresso recebido:', data);
        });
        
        // Listener global para qa_progress
        socket.on('qa_progress', (data) => {
            // Distinguir entre geração e vetorização baseado no step
            if (data.step === 'vectorizing') {
                // Progresso de vetorização - usa barra verde próxima ao botão
                showVectorizeProgress(data.message, data.progress);
            } else if (data.step === 'completed' && data.message.includes('vetorizado')) {
                // Completou vetorização - usa barra verde
                showVectorizeProgress(data.message, data.progress);
                setTimeout(() => {
                    hideVectorizeProgress();
                }, 2000);
            } else if (data.step === 'error' && data.message.includes('vetoriza')) {
                // Erro na vetorização - usa barra verde  
                showVectorizeProgress(data.message, data.progress);
                setTimeout(() => {
                    hideVectorizeProgress();
                }, 2000);
            } else {
                // Progresso de geração - usa barra azul original
                showQaProgress(data.message, data.progress);
                
                // Auto-esconder quando completado ou erro
                if (data.step === 'completed' || data.step === 'error') {
                    setTimeout(() => {
                        hideQaProgress();
                    }, 2000);
                }
            }
        });
        
        // WebSocket handlers
        socket.on('chat_response', (data) => {
            if (data.error) {
                addChatMessage('error', `Erro: ${data.error}`);
            } else {
                addChatMessage('assistant', data.response, {
                    sources: data.sources,
                    similarity_threshold: data.similarity_threshold
                });
            }
            
            isProcessing = false;
            updateSendButton();
        });
        
        // Global variables
        let currentSessionId = null;
        let isProcessing = false;
        let collections = [];
        let documents = [];
        let embeddingModels = [];
        
        // DOM elements
        const navButtons = document.querySelectorAll('.sidebar-item');
        const contentSections = document.querySelectorAll('.content-section');
        const statusIndicator = document.getElementById('status-indicator');
        const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
        const sidebar = document.querySelector('.sidebar');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        
        // Navigation functionality
        navButtons.forEach(button => {
            button.addEventListener('click', () => {
                const navId = button.id.replace('-nav', '');
                
                // Update active nav
                navButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                
                // Show content
                contentSections.forEach(section => section.classList.add('hidden'));
                document.getElementById(`${navId}-content`).classList.remove('hidden');
                
                // Update page title and subtitle
                updatePageHeader(navId);
                
                // Load sessions when semantic tab is opened
                if (navId === 'semantic') {
                    console.log('📁 Carregando sessões para aba:', navId);
                    loadSessionsForSemanticSelector();
                }
                
                // Close mobile menu if open
                if (window.innerWidth <= 768) {
                    sidebar.classList.remove('open');
                }
            });
        });
        
        // Mobile menu toggle
        mobileMenuToggle.addEventListener('click', () => {
            sidebar.classList.toggle('open');
            sidebarOverlay.classList.toggle('open');
        });
        
        // Close mobile menu when clicking overlay
        sidebarOverlay.addEventListener('click', () => {
            sidebar.classList.remove('open');
            sidebarOverlay.classList.remove('open');
        });
        
        // Close mobile menu when clicking outside
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 768 && 
                !sidebar.contains(e.target) && 
                !mobileMenuToggle.contains(e.target)) {
                sidebar.classList.remove('open');
                sidebarOverlay.classList.remove('open');
            }
        });
        
        function updatePageHeader(navId) {
            const pageTitle = document.getElementById('page-title');
            const pageSubtitle = document.getElementById('page-subtitle');
            
            const headers = {
                'upload': {
                    title: 'Upload de Documento',
                    subtitle: 'Faça upload de documentos para processamento'
                },
                'collections': {
                    title: 'Collections',
                    subtitle: 'Gerencie suas collections de documentos'
                },
                'editor': {
                    title: 'Editor de Conteúdo',
                    subtitle: 'Crie e edite perguntas e respostas'
                },
                'chat': {
                                    title: 'Busca por Similaridade',
                subtitle: 'Busque documentos por similaridade de conteúdo'
                },
                'semantic': {
                    title: 'Chat Multi-Agente',
                    subtitle: 'Obtenha respostas de múltiplos modelos de IA'
                },
                'semantic-search': {
                    title: 'Busca Semântica',
                    subtitle: 'Busca inteligente por modelo de IA com retorno de chunks'
                },
                'history': {
                    title: 'Histórico',
                    subtitle: 'Visualize sessões anteriores'
                }
            };
            
            if (headers[navId]) {
                pageTitle.textContent = headers[navId].title;
                pageSubtitle.textContent = headers[navId].subtitle;
            }
        }
        
        // Toast notification function
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            
            const colors = {
                success: 'bg-green-500',
                error: 'bg-red-500',
                warning: 'bg-yellow-500',
                info: 'bg-blue-500'
            };
            
            toast.className = `${colors[type]} text-white px-4 py-3 rounded-lg shadow-lg transform translate-x-full transition-all duration-300`;
            toast.innerHTML = `
                <div class="flex items-center justify-between">
                    <span>${message}</span>
                    <button onclick="this.parentElement.parentElement.remove()" class="ml-4 text-white hover:text-gray-200">
                        <i data-lucide="x" class="w-4 h-4"></i>
                    </button>
                </div>
            `;
            
            container.appendChild(toast);
            
            // Animate in
            setTimeout(() => {
                toast.classList.remove('translate-x-full');
            }, 100);
            
            // Auto remove after 5 seconds
            setTimeout(() => {
                if (toast.parentElement) {
                    toast.classList.add('translate-x-full');
                    setTimeout(() => {
                        if (toast.parentElement) {
                            toast.remove();
                        }
                    }, 300);
                }
            }, 5000);
            
            // Reinitialize icons
            lucide.createIcons();
        }
        
        // Socket.IO events
        socket.on('connect', () => {
            statusIndicator.innerHTML = '<div class="w-2 h-2 bg-green-500 rounded-full"></div><span class="text-sm text-gray-600">Conectado</span>';
        });
        
        socket.on('disconnect', () => {
            statusIndicator.innerHTML = '<div class="w-2 h-2 bg-red-500 rounded-full"></div><span class="text-sm text-gray-600">Desconectado</span>';
        });
        
        socket.on('chat_response', (data) => {
            addChatMessage('assistant', data.response, data);
            isProcessing = false;
            updateSendButton();
            

        });
        
        socket.on('chat_error', (data) => {
            addChatMessage('error', `Erro: ${data.error}`);
            isProcessing = false;
            updateSendButton();
        });
        
        // File upload functionality - will be initialized in DOMContentLoaded
        let fileInput, fileInfo, uploadBtn, uploadProgress, progressBar, progressText;
        let uploadZone, uploadPlaceholder, filePreview, fileName, fileSize, removeFileBtn;
        let filesQueue, filesList, charsetTestBtn, charsetTestResults, charsetTestContent;
        let selectedFiles = []; // Array para armazenar arquivos selecionados
        
        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Botão de nova sessão
            const newSessionBtn = document.getElementById('new-session-btn');
            if (newSessionBtn) {
                newSessionBtn.addEventListener('click', createNewSession);
            }
        });
        
        async function createNewSession() {
            try {
                const sessionName = prompt('Digite um nome para a nova sessão:', 'Nova Sessão');
                if (!sessionName) return;
                
                const response = await fetch('/api/sessions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ name: sessionName })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showToast(`✅ Sessão "${sessionName}" criada com sucesso`, 'success');
                    
                    // Atualizar sessão atual
                    currentSessionId = result.session_id;
                    

                    
                    // Limpar chat
                    const chatMessages = document.getElementById('chat-messages');
                    chatMessages.innerHTML = '';
                    
                    // Mudar para aba de chat
                    showContent('chat');
                    
                    // Recarregar lista de sessões
                    await loadSessions();
                } else {
                    showToast('❌ Erro ao criar sessão', 'error');
                }
            } catch (error) {
                console.error('Erro ao criar sessão:', error);
                showToast('❌ Erro ao criar sessão', 'error');
            }
        }
        
        // Initialize upload functionality
        function initializeUpload() {
            // Get DOM elements
            fileInput = document.getElementById('file-input');
            fileInfo = document.getElementById('file-info');
            uploadBtn = document.getElementById('upload-btn');
            console.log('🔍 DEBUG: uploadBtn encontrado?', !!uploadBtn, uploadBtn);
            uploadProgress = document.getElementById('upload-progress');
            progressBar = document.getElementById('progress-bar');
            progressText = document.getElementById('progress-text');
            uploadZone = document.getElementById('upload-zone');
            uploadPlaceholder = document.getElementById('upload-placeholder');
            filePreview = document.getElementById('file-preview');
            fileName = document.getElementById('file-name');
            fileSize = document.getElementById('file-size');
            removeFileBtn = document.getElementById('remove-file');
            filesQueue = document.getElementById('files-queue');
            filesList = document.getElementById('files-list');
            charsetTestBtn = document.getElementById('charset-test-btn');
            charsetTestResults = document.getElementById('charset-test-results');
            charsetTestContent = document.getElementById('charset-test-content');
            

            

            

            
            // Drag and drop functionality
            if (uploadZone) {
                uploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadZone.classList.add('dragover');
                });
                
                uploadZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadZone.classList.remove('dragover');
                });
                
                uploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadZone.classList.remove('dragover');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0 && fileInput) {
                        fileInput.files = files;
                        handleFileSelection(files[0]);
                    }
                });
            }
            
            // File input change event
            if (fileInput) {
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    handleFileSelection(file);
                });
            }
            
            // Remove file button event
            if (removeFileBtn) {
                removeFileBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    clearFileSelection();
                    showToast('Arquivo removido com sucesso', 'success');
                });
            }
        }
        
        function handleFileSelection(file) {
            console.log('📁 Arquivo selecionado:', file ? file.name : 'null');
            console.log('🎯 Elementos UI:', {
                fileName: !!fileName,
                fileSize: !!fileSize,
                uploadPlaceholder: !!uploadPlaceholder,
                filePreview: !!filePreview
            });
            
            if (file && fileName && fileSize && uploadPlaceholder && filePreview) {
                
                // Show file preview
                fileName.textContent = file.name;
                fileSize.textContent = `${(file.size / 1024 / 1024).toFixed(2)} MB`;
                
                // Update file icon based on type
                const fileIcon = filePreview.querySelector('i[data-lucide]');
                const extension = file.name.split('.').pop().toLowerCase();
                
                // Set appropriate icon and color based on file type
                let iconName = 'file-text';
                let iconColor = 'text-blue-600';
                let bgColor = 'bg-blue-100';
                
                // Only update if icon exists
                if (fileIcon) {
                    fileIcon.className = '';
                }
                
                switch(extension) {
                    case 'pdf':
                        iconName = 'file-text';
                        iconColor = 'text-red-600';
                        bgColor = 'bg-red-100';
                        break;
                    case 'docx':
                        iconName = 'file-text';
                        iconColor = 'text-blue-600';
                        bgColor = 'bg-blue-100';
                        break;
                    case 'txt':
                        iconName = 'file-text';
                        iconColor = 'text-gray-600';
                        bgColor = 'bg-gray-100';
                        break;
                    case 'md':
                        iconName = 'file-text';
                        iconColor = 'text-purple-600';
                        bgColor = 'bg-purple-100';
                        break;
                    default:
                        iconName = 'file-text';
                        iconColor = 'text-gray-600';
                        bgColor = 'bg-gray-100';
                }
                
                // Update icon container background
                const iconContainer = filePreview.querySelector('.w-12.h-12');
                if (iconContainer) {
                    iconContainer.className = `w-12 h-12 ${bgColor} rounded-lg flex items-center justify-center`;
                }
                
                // Update icon
                if (fileIcon) {
                    fileIcon.className = `h-6 w-6 ${iconColor}`;
                    fileIcon.setAttribute('data-lucide', iconName);
                }
                
                // Reinitialize Lucide icons (removed due to CSP)
                // lucide.createIcons();
                

                

                
                uploadPlaceholder.classList.add('hidden');
                filePreview.classList.remove('hidden');
                filePreview.classList.add('file-preview-enter');
                
                // Add success animation
                if (uploadZone) {
                    uploadZone.classList.add('border-green-400', 'bg-green-50');
                    setTimeout(() => {
                        uploadZone.classList.remove('border-green-400', 'bg-green-50');
                    }, 1000);
                }
                
                // Update file info for backward compatibility
                if (fileInfo) {
                    fileInfo.textContent = `Arquivo selecionado: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
                    fileInfo.classList.remove('hidden');
                }
                
                // Add file to queue
                console.log('📝 Adicionando arquivo à fila...');
                addFileToQueue(file);
            }
        }
        
        function clearFileSelection() {
            if (fileInput) fileInput.value = '';
            if (uploadPlaceholder) uploadPlaceholder.classList.remove('hidden');
            if (filePreview) filePreview.classList.add('hidden');
            if (fileInfo) fileInfo.classList.add('hidden');
            
            // Clear the current file preview but keep the queue
        }
        
        function addFileToQueue(file) {
            console.log('📋 Adicionando à fila:', file.name);
            
            // Create unique ID for file
            const fileId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // Add to selectedFiles array
            selectedFiles.push({
                id: fileId,
                file: file,
                name: file.name,
                size: file.size,
                status: 'ready' // ready, processing, completed, error
            });
            
            console.log('📊 Total de arquivos na fila:', selectedFiles.length);
            updateFilesQueue();
        }
        
        // Make this function globally available
        window.removeFileFromQueue = function(fileId) {
            selectedFiles = selectedFiles.filter(f => f.id !== fileId);
            updateFilesQueue();

        }
        
        function updateFilesQueue() {
            console.log('🔄 Atualizando fila de arquivos...');
            console.log('🎯 Elementos fila:', {
                filesQueue: !!filesQueue,
                filesList: !!filesList
            });
            console.log('📊 Arquivos na fila:', selectedFiles.length);
            
            if (!filesQueue || !filesList) {
                console.log('❌ Elementos da fila não encontrados!');
                return;
            }
            
            if (selectedFiles.length === 0) {
                console.log('📭 Fila vazia, ocultando...');
                filesQueue.classList.add('hidden');
                return;
            }
            
            console.log('📋 Mostrando fila com arquivos...');
            filesQueue.classList.remove('hidden');
            filesList.innerHTML = '';
            
            selectedFiles.forEach(fileItem => {
                const fileDiv = document.createElement('div');
                fileDiv.className = 'flex items-center justify-between p-3 bg-white rounded-lg border border-gray-200';
                
                const statusColor = {
                    'ready': 'text-blue-600 bg-blue-100',
                    'processing': 'text-yellow-600 bg-yellow-100',
                    'completed': 'text-green-600 bg-green-100',
                    'error': 'text-red-600 bg-red-100'
                };
                
                const statusText = {
                    'ready': 'Pronto',
                    'processing': 'Processando',
                    'completed': 'Completo',
                    'error': 'Erro'
                };
                
                fileDiv.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <i data-lucide="file-text" class="w-5 h-5 text-gray-500"></i>
                        <div>
                            <div class="text-sm font-medium text-gray-900">${fileItem.name}</div>
                            <div class="text-xs text-gray-500">${(fileItem.size / 1024 / 1024).toFixed(2)} MB</div>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span class="px-2 py-1 text-xs font-medium rounded-full ${statusColor[fileItem.status]}">
                            ${statusText[fileItem.status]}
                        </span>
                        <button onclick="removeFileFromQueue('${fileItem.id}')" class="p-1 text-gray-400 hover:text-red-500 transition-colors">
                            <i data-lucide="x" class="w-4 h-4"></i>
                        </button>
                    </div>
                `;
                
                filesList.appendChild(fileDiv);
            });
            
            // Reinitialize Lucide icons (removed due to CSP)
            // lucide.createIcons();
            
            // Upload button event
            console.log('🔍 DEBUG: Verificando uploadBtn para event listener...', !!uploadBtn);
            if (uploadBtn) {
                console.log('✅ Botão upload encontrado, adicionando event listener');
                uploadBtn.addEventListener('click', async () => {
                    console.log('🚀 Botão upload clicado!');
                    
                    // Limpar mensagens de erro anteriores e resetar interface
                    const progressContainer = uploadProgress.querySelector('.bg-red-50, .bg-green-50, .bg-gray-100');
                    if (progressContainer) {
                        // Reset para estado inicial de loading
                        progressContainer.className = 'bg-gray-100 rounded-lg p-4 border border-gray-200';
                        progressContainer.innerHTML = `
                            <div class="flex items-center space-x-3 mb-3">
                                <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
                                <span class="text-sm font-medium text-gray-700">Processando documento...</span>
                            </div>
                            <div class="bg-gray-200 rounded-full h-2">
                                <div id="upload-progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                            </div>
                            <div id="upload-progress-text" class="text-sm text-gray-600 mt-2">Iniciando processamento...</div>
                        `;
                    }
                    
                    // Limpar mensagens de status anteriores
                    updateVectorizationStatus('', '');
                    
                    console.log('🧼 Interface resetada para novo processamento');
                    
                    console.log('📊 Estado atual:', {
                        fileInput: !!fileInput,
                        files: fileInput?.files?.length || 0,
                        selectedFiles: selectedFiles.length
                    });
                    
                    // Usar arquivo da fila em vez de fileInput
                    const file = selectedFiles.length > 0 ? selectedFiles[0].file : fileInput.files[0];
                    const collectionSelect = document.getElementById('upload-collection-select');
                    
                    console.log('📁 Arquivo para upload:', file ? file.name : 'nenhum');
                    console.log('📋 Collection selecionada:', collectionSelect.value);
                    
                    if (!file) {
                        console.log('❌ Nenhum arquivo encontrado');
                        showToast('Selecione um arquivo primeiro', 'warning');
                        return;
                    }
                    
                    if (!collectionSelect.value) {
                        console.log('❌ Collection não selecionada');
                        showToast('Selecione uma collection primeiro', 'warning');
                        return;
                    }
                    
                    console.log('✅ Todas as validações passaram, iniciando upload...');
                    
                    // Re-selecionar elementos de progresso após criação dinâmica
                    progressBar = document.getElementById('upload-progress-bar');
                    progressText = document.getElementById('upload-progress-text');
                    
                    console.log('🎯 Elementos re-selecionados:', {
                        progressBar: !!progressBar,
                        progressText: !!progressText
                    });
                    
                    // Gerar session_id único para este upload
                    const sessionId = 'upload_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    console.log('🆔 Session ID gerado:', sessionId);
                    
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('collection_name', collectionSelect.value);
                    formData.append('enhance', document.getElementById('upload-enhance').value);
                    formData.append('session_id', sessionId);
                    
                    uploadBtn.disabled = true;
                    uploadProgress.classList.remove('hidden');
                    updateVectorizationStatus('processing', 'Iniciando processamento...');
                    
                    // Configurar listener para progresso em tempo real
                    let progressInterval = null;
                    
                    const uploadProgressListener = (data) => {
                        console.log('📡 Progresso recebido no front-end:', data);
                        
                        console.log('🔍 Elementos DOM:', {
                            progressBar: !!progressBar,
                            progressText: !!progressText,
                            progressBarWidth: progressBar ? progressBar.style.width : 'N/A'
                        });
                        
                        if (data.step && data.progress !== undefined && data.message) {
                            console.log('✅ Atualizando progresso:', data.progress + '%');
                            
                            // Atualizar barra de progresso
                            if (progressBar) {
                                progressBar.style.width = `${data.progress}%`;
                                console.log('📊 Barra atualizada para:', progressBar.style.width);
                            }
                            
                            // Atualizar texto de progresso
                            if (progressText) {
                                progressText.textContent = `${data.message} (${data.progress}%)`;
                                console.log('📝 Texto atualizado para:', progressText.textContent);
                            }
                            
                            // Atualizar status baseado no step
                            if (data.step === 'error') {
                                updateVectorizationStatus('error', data.message);
                            } else if (data.step === 'completed') {
                                updateVectorizationStatus('success', data.message);
                            } else {
                                updateVectorizationStatus('processing', data.message);
                            }
                        } else {
                            console.log('⚠️ Dados de progresso incompletos:', data);
                        }
                    };
                    
                    // Adicionar listener temporário para este upload
                    socket.on('upload_progress', uploadProgressListener);
                    
                    // Remover listener após 5 minutos (timeout)
                    const cleanupTimeout = setTimeout(() => {
                        socket.off('upload_progress', uploadProgressListener);
                        console.log('📏 Listener de progresso removido por timeout');
                    }, 300000); // 5 minutos
                    
                    try {
                        const response = await fetch('/api/upload', {
                            method: 'POST',
                            body: formData
                        });
                        
                        // Limpar listener e timeout
                        clearTimeout(cleanupTimeout);
                        socket.off('upload_progress', uploadProgressListener);
                        console.log('📏 Listener de progresso removido após upload');
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            // O progresso já foi atualizado via WebSocket, apenas confirmamos o sucesso
                            console.log('✅ Upload concluído com sucesso:', result);
                            
                            // Show success in progress area
                            const progressContainer = uploadProgress.querySelector('.bg-gray-100, .bg-green-50, .bg-red-50');
                            if (progressContainer) {
                                progressContainer.className = 'bg-green-50 rounded-lg p-4 border border-green-200';
                                progressContainer.innerHTML = `
                                    <div class="flex items-center space-x-3 mb-3">
                                        <i data-lucide="check-circle" class="h-5 w-5 text-green-500"></i>
                                        <span class="text-sm font-medium text-green-700">Documento processado com sucesso!</span>
                                    </div>
                                    <div class="text-sm text-green-600">Arquivo: ${result.file_name}</div>
                                    <div class="text-sm text-green-600">Collection: ${result.collection_name}</div>
                                    <div class="text-sm text-green-600">Chunks criados: ${result.chunks_count}</div>
                                `;
                            }
                            
                            // Update status
                            updateVectorizationStatus('success', `Documento ${result.file_name} processado com sucesso!`);
                            
                            // Show success message
                            showToast(result.message, 'success');
                            
                            // Reload collections to show updated list
                            await loadCollections();
                            
                            // If we're on the collections page, refresh the current view
                            const collectionsContent = document.getElementById('collections-content');
                            if (!collectionsContent.classList.contains('hidden')) {
                                updateCollectionsList();
                            }
                            
                            // Reset form
                            clearFileSelection();
                            
                            setTimeout(() => {
                                uploadProgress.classList.add('hidden');
                                const resetProgressBar = document.getElementById('upload-progress-bar');
                                const resetProgressText = document.getElementById('upload-progress-text');
                                if (resetProgressBar) resetProgressBar.style.width = '0%';
                                if (resetProgressText) resetProgressText.textContent = 'Iniciando processamento...';
                                
                                // Reset progress container to original state
                                const resetContainer = uploadProgress.querySelector('.bg-gray-100, .bg-green-50, .bg-red-50');
                                if (resetContainer) {
                                    resetContainer.className = 'bg-gray-100 rounded-lg p-4 border border-gray-200';
                                    resetContainer.innerHTML = `
                                        <div class="flex items-center space-x-3 mb-3">
                                            <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
                                            <span class="text-sm font-medium text-gray-700">Processando documento...</span>
                                        </div>
                                        <div class="bg-gray-200 rounded-full h-2">
                                            <div id="upload-progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                        </div>
                                        <div id="upload-progress-text" class="text-sm text-gray-600 mt-2">Iniciando processamento...</div>
                                    `;
                                }
                            }, 3000);
                        } else {
                            throw new Error(result.error);
                        }
                    } catch (error) {
                        // Limpar listener e timeout em caso de erro
                        clearTimeout(cleanupTimeout);
                        socket.off('upload_progress', uploadProgressListener);
                        console.log('📏 Listener de progresso removido após erro');
                        
                        console.error('❌ Erro no upload:', error);
                        progressText.textContent = `Erro: ${error.message}`;
                        updateVectorizationStatus('error', `Erro no upload: ${error.message}`);
                        showToast(`Erro no upload: ${error.message}`, 'error');
                        
                        // Show error in progress area
                        const progressContainer = uploadProgress.querySelector('.bg-gray-100, .bg-green-50, .bg-red-50');
                        if (progressContainer) {
                            progressContainer.className = 'bg-red-50 rounded-lg p-4 border border-red-200';
                            progressContainer.innerHTML = `
                                <div class="flex items-center space-x-3 mb-3">
                                    <i data-lucide="alert-circle" class="h-5 w-5 text-red-500"></i>
                                    <span class="text-sm font-medium text-red-700">Erro no processamento</span>
                                </div>
                                <div class="text-sm text-red-600">${error.message}</div>
                            `;
                        }
                    } finally {
                        uploadBtn.disabled = false;
                    }
                });
            } else {
                console.log('❌ Botão upload NÃO encontrado! ID:', 'upload-btn');
            }
            
            // Charset test button event
            if (charsetTestBtn) {
                console.log('✅ Botão teste charset encontrado, adicionando event listener');
                charsetTestBtn.addEventListener('click', async () => {
                    console.log('🧪 Botão teste charset clicado!');
                    
                    // Verificar se há arquivo selecionado
                    const file = selectedFiles.length > 0 ? selectedFiles[0].file : fileInput?.files[0];
                    
                    if (!file) {
                        showToast('Selecione um arquivo primeiro para testar o charset', 'warning');
                        return;
                    }
                    
                    console.log('📜 Testando charset do arquivo:', file.name);
                    
                    // Desabilitar botão durante teste
                    charsetTestBtn.disabled = true;
                    charsetTestBtn.textContent = '🔄 Testando...';
                    
                    try {
                        // Ler arquivo como texto
                        const fileText = await readFileAsText(file);
                        
                        if (!fileText || fileText.length === 0) {
                            throw new Error('Arquivo vazio ou não pode ser lido como texto');
                        }
                        
                        console.log(`📊 Arquivo lido: ${fileText.length} caracteres`);
                        
                        // Testar charset usando endpoint de diagnóstico
                        const response = await fetch('/api/debug/charset-test', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                text: fileText.substring(0, 5000) // Primeiros 5k caracteres para teste
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            displayCharsetTestResults(result.diagnosis, result.recommendation);
                            showToast('Teste de charset concluído!', 'success');
                        } else {
                            throw new Error(result.error || 'Erro no teste de charset');
                        }
                        
                    } catch (error) {
                        console.error('❌ Erro no teste de charset:', error);
                        showToast(`Erro no teste de charset: ${error.message}`, 'error');
                        
                        // Mostrar erro nos resultados
                        charsetTestResults.classList.remove('hidden');
                        charsetTestContent.innerHTML = `
                            <div class="bg-red-50 border border-red-200 rounded-lg p-3">
                                <div class="flex items-center space-x-2">
                                    <div class="w-2 h-2 bg-red-500 rounded-full"></div>
                                    <span class="text-sm font-medium text-red-700">❌ Erro no Teste</span>
                                </div>
                                <div class="text-sm text-red-600 mt-1">${error.message}</div>
                            </div>
                        `;
                        
                    } finally {
                        // Restaurar botão
                        charsetTestBtn.disabled = false;
                        charsetTestBtn.textContent = '🧪 Testar Charset';
                    }
                });
            } else {
                console.log('❌ Botão teste charset NÃO encontrado! ID:', 'charset-test-btn');
            }
        }
        
        // Editor functionality
        const generateQaBtn = document.getElementById('generate-qa-btn');
        const vectorizeContentBtn = document.getElementById('vectorize-content-btn');
        const qaResults = document.getElementById('qa-results');
        const qaList = document.getElementById('qa-list');
        const qaProgress = document.getElementById('qa-progress');
        const downloadQaBtn = document.getElementById('download-qa-btn');
        
        // Temperature slider
        const temperatureSlider = document.getElementById('temperature');
        const temperatureValue = document.getElementById('temperature-value');
        if (temperatureSlider && temperatureValue) {
            temperatureSlider.addEventListener('input', () => {
                temperatureValue.textContent = temperatureSlider.value;
            });
        }
        
        // Collection selection change handler
        const editorCollectionSelect = document.getElementById('editor-collection-select');
        if (editorCollectionSelect) {
            editorCollectionSelect.addEventListener('change', async () => {
                const selectedCollection = editorCollectionSelect.value;
                console.log('🔄 Collection selecionada:', selectedCollection);
                
                if (selectedCollection) {
                    // Recarregar documentos para a collection selecionada
                    await loadDocumentsForCollection(selectedCollection);
                } else {
                    // Limpar seletor de documentos
                    updateDocumentSelect([]);
                    hideDocumentInfo();
                }
            });
        }

        // Document selection change handler
        const editorDocumentSelect = document.getElementById('editor-document-select');
        if (editorDocumentSelect) {
            editorDocumentSelect.addEventListener('change', async () => {
                const selectedDocument = editorDocumentSelect.value;
                if (selectedDocument) {
                    await loadDocumentInfo(selectedDocument);
                } else {
                    hideDocumentInfo();
                }
            });
        }
        
        if (generateQaBtn) {
            generateQaBtn.addEventListener('click', async () => {
                const collectionSelect = document.getElementById('editor-collection-select');
                const documentSelect = document.getElementById('editor-document-select');
                
                if (!collectionSelect.value) {
                    showToast('Selecione uma collection de origem primeiro', 'warning');
                    return;
                }
                
                if (!documentSelect.value) {
                    showToast('Selecione um documento primeiro', 'warning');
                    return;
                }
                
                // Get form values
                const numQuestions = parseInt(document.getElementById('num-questions').value) || 50;
                const difficulty = document.getElementById('difficulty').value;
                const temperature = parseFloat(document.getElementById('temperature').value) || 0.5;
                const contextKeywords = document.getElementById('context-keywords').value;
                const customPrompt = document.getElementById('custom-prompt').value;
                
                generateQaBtn.disabled = true;
                generateQaBtn.textContent = 'Gerando...';
                showQaProgress('Preparando geração de Q&As...', 0);
                
                try {
                    console.log('🔍 DEBUG [QA_GENERATE] Iniciando geração de Q&A:', {
                        collection: collectionSelect.value,
                        document: documentSelect.value,
                        numQuestions: numQuestions,
                        difficulty: difficulty,
                        temperature: temperature,
                        contextKeywords: contextKeywords
                    });
                    
                    // Obter o conteúdo do documento selecionado
                    const contentUrl = `/api/collections/${collectionSelect.value}/content?document=${encodeURIComponent(documentSelect.value)}`;
                    console.log('📡 DEBUG [QA_GENERATE] Buscando conteúdo do documento:', contentUrl);
                    
                    const contentResponse = await fetch(contentUrl);
                    console.log('📡 DEBUG [QA_GENERATE] Resposta do content:', {
                        status: contentResponse.status,
                        statusText: contentResponse.statusText,
                        ok: contentResponse.ok
                    });
                    
                    const contentResult = await contentResponse.json();
                    console.log('📄 DEBUG [QA_GENERATE] Resultado do content:', contentResult);
                    
                    if (!contentResult.success) {
                        console.error('❌ DEBUG [QA_GENERATE] Falha ao obter conteúdo:', contentResult);
                        throw new Error(contentResult.error || 'Erro ao obter conteúdo do documento');
                    }
                    
                    if (!contentResult.content.trim()) {
                        console.warn('⚠️ DEBUG [QA_GENERATE] Documento sem conteúdo');
                        showToast('O documento selecionado não possui conteúdo para gerar Q&A', 'warning');
                        return;
                    }
                    
                    console.log('✅ DEBUG [QA_GENERATE] Conteúdo obtido com sucesso:', {
                        contentLength: contentResult.content.length,
                        preview: contentResult.content.substring(0, 200) + '...'
                    });
                    
                    // Gerar Q&A (sem vetorizar ainda)
                    const requestData = {
                        content: contentResult.content,
                        num_questions: numQuestions,
                        context_keywords: contextKeywords,
                        difficulty: difficulty,
                        temperature: temperature,
                        custom_prompt: customPrompt
                    };
                    
                    console.log('📤 Enviando dados para qa-generate:', {
                        contentLength: contentResult.content?.length || 0,
                        numQuestions,
                        difficulty,
                        temperature,
                        contextKeywords,
                        customPrompt: customPrompt?.substring(0, 50) + '...'
                    });
                    
                    const response = await fetch('/api/qa-generate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    const result = await response.json();
                    
                    console.log('📥 Resposta qa-generate:', {
                        status: response.status,
                        success: result.success,
                        error: result.error,
                        qaCount: result.qa_count
                    });
                    
                    if (!response.ok) {
                        console.error('❌ Erro HTTP:', response.status, result);
                        throw new Error(result.error || `Erro HTTP ${response.status}`);
                    }
                    
                    if (result.success) {
                        // Armazenar o conteúdo Q&A para uso posterior
                        window.currentQAContent = result.qa_content;
                        
                        displayQAResults(result.qa_content);
                        hideQaProgress();
                        showToast(`${result.qa_count} Q&As gerados com sucesso - Pronto para preview e vetorização`, 'success');
                        
                        // Habilitar botões de vetorização e edição
                        updateVectorizationUI();
                        
                        // Popular o seletor de collections destino quando Q&As são geradas
                        await populateQACollectionSelect();
                    } else {
                        throw new Error(result.error);
                    }
                } catch (error) {
                    hideQaProgress();
                    showToast(`Erro ao gerar Q&A: ${error.message}`, 'error');
                } finally {
                    generateQaBtn.disabled = false;
                    generateQaBtn.textContent = '🚀 Gerar Q&As';
                }
            });
        }
        
        if (vectorizeContentBtn) {
            vectorizeContentBtn.addEventListener('click', async () => {
                const collectionSelect = document.getElementById('editor-collection-select');
                
                if (!collectionSelect.value) {
                    showToast('Selecione uma collection primeiro', 'warning');
                    return;
                }
                
                vectorizeContentBtn.disabled = true;
                vectorizeContentBtn.textContent = 'Vetorizando...';
                showQaProgress('Preparando vetorização...', 0);
                
                try {
                    // Obter conteúdo da collection
                    const contentResponse = await fetch(`/api/collections/${collectionSelect.value}/content`);
                    const contentResult = await contentResponse.json();
                    
                    if (!contentResult.success) {
                        throw new Error('Erro ao obter conteúdo da collection');
                    }
                    
                    if (!contentResult.content.trim()) {
                        showToast('A collection selecionada não possui documentos para vetorizar', 'warning');
                        return;
                    }
                    
                    // Aqui você pode implementar a lógica de vetorização se necessário
                    showToast('Conteúdo já está vetorizado na collection', 'info');
                    
                } catch (error) {
                    showToast(`Erro ao vetorizar conteúdo: ${error.message}`, 'error');
                } finally {
                    vectorizeContentBtn.disabled = false;
                    vectorizeContentBtn.textContent = '📊 Vetorizar Conteúdo';
                    hideQaProgress();
                }
            });
        }
        
        // Chat functionality
        const chatInput = document.getElementById('chat-input');
        const sendMessageBtn = document.getElementById('send-message-btn');
        const chatMessages = document.getElementById('chat-messages');
        
        // Chat multi-agente functionality
        const semanticInput = document.getElementById('semantic-input');
        const sendSemanticBtn = document.getElementById('send-semantic-btn');
        const semanticMessages = document.getElementById('semantic-messages');
        

        
        sendMessageBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        // Chat multi-agente event listeners
        sendSemanticBtn.addEventListener('click', sendSemanticMessage);
        semanticInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendSemanticMessage();
            }
        });
        
        // Session selector functionality
        let sessionsList = [];
        

        

        
        // Funções para o seletor de sessões na aba semantic
        async function loadSessionsForSemanticSelector() {
            console.log('🔍 Carregando sessões para o seletor semantic...');
            try {
                const response = await fetch('/api/sessions');
                const result = await response.json();
                
                console.log('📡 Response sessões semantic:', response.status, result);
                
                if (result.success) {
                    sessionsList = result.sessions || [];
                    console.log('📁 Sessões carregadas:', sessionsList.length);
                    updateSemanticSessionSelector();
                } else {
                    console.error('❌ Erro na resposta da API:', result);
                }
            } catch (error) {
                console.error('❌ Erro ao carregar sessões para o seletor semantic:', error);
            }
        }
        
        function updateSemanticSessionSelector() {
            console.log('🔄 Atualizando seletor de sessões semantic...');
            const sessionSelect = document.getElementById('semantic-session-select');
            const currentSessionInfo = document.getElementById('current-semantic-session-info');
            const currentSessionName = document.getElementById('current-semantic-session-name');
            
            if (!sessionSelect) {
                console.error('❌ Elemento semantic-session-select não encontrado!');
                return;
            }
            
            console.log('📁 Sessões disponíveis:', sessionsList);
            
            // Limpar opções existentes
            sessionSelect.innerHTML = '<option value="">Nova sessão</option>';
            
            // Adicionar sessões existentes
            sessionsList.forEach(session => {
                const option = document.createElement('option');
                option.value = session.session_id;
                option.textContent = `${session.name} (${session.message_count} mensagens)`;
                sessionSelect.appendChild(option);
                console.log('➕ Opção adicionada:', session.name);
            });
            
            // Atualizar informação da sessão atual
            if (currentSessionId) {
                const currentSession = sessionsList.find(s => s.session_id === currentSessionId);
                if (currentSession) {
                    currentSessionInfo.classList.remove('hidden');
                    currentSessionName.textContent = currentSession.name;
                    sessionSelect.value = currentSessionId;
                }
            }
            
            console.log('✅ Seletor de sessões semantic atualizado');
        }
        
        async function handleSemanticSessionSelection() {
            const sessionSelect = document.getElementById('semantic-session-select');
            const selectedSessionId = sessionSelect.value;
            
            if (selectedSessionId) {
                // Carregar sessão selecionada
                loadSemanticSessionMessages(selectedSessionId);
            } else {
                // Nova sessão - criar automaticamente
                await createNewSessionForSemantic();
            }
        }
        
        async function loadSemanticSessionMessages(sessionId) {
            try {
                const response = await fetch(`/api/sessions/${sessionId}`);
                const result = await response.json();
                
                if (result.success && result.session) {
                    const session = result.session;
                    
                    // Atualizar sessão atual
                    currentSessionId = sessionId;
                    const sessionName = session.name || `Sessão ${sessionId.substring(0, 8)}...`;
                    
                    // Atualizar interface
                    document.getElementById('current-semantic-session-name').textContent = sessionName;
                    document.getElementById('current-semantic-session-info').classList.remove('hidden');
                    
                    // Limpar chat atual
                    const semanticMessages = document.getElementById('semantic-messages');
                    semanticMessages.innerHTML = '';
                    
                    // Carregar mensagens da sessão
                    if (session.messages && session.messages.length > 0) {
                        session.messages.forEach(message => {
                            addSemanticMessage(message.role, message.content, {
                                sources: message.sources || [],
                                fromHistory: true
                            });
                        });
                    } else {
                        addSemanticMessage('system', 'Sessão carregada. Você pode continuar a conversa.', {
                            fromHistory: true
                        });
                    }
                    
                    showToast(`✅ Sessão "${sessionName}" carregada`, 'success');
                } else {
                    showToast('❌ Erro ao carregar sessão', 'error');
                }
            } catch (error) {
                console.error('Erro ao carregar mensagens da sessão semantic:', error);
                showToast('❌ Erro ao carregar sessão', 'error');
            }
        }
        
        async function createNewSessionForSemantic() {
            const sessionName = prompt('Digite um nome para a nova sessão:', 'Nova Sessão');
            if (!sessionName) {
                // Se cancelou, voltar para a sessão anterior
                if (currentSessionId) {
                    const sessionSelect = document.getElementById('semantic-session-select');
                    sessionSelect.value = currentSessionId;
                }
                return;
            }
            
            try {
                const response = await fetch('/api/sessions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ name: sessionName })
                });
                
                const result = await response.json();
                if (result.success) {
                    // Atualizar sessão atual
                    currentSessionId = result.session_id;
                    
                    // Limpar chat
                    const semanticMessages = document.getElementById('semantic-messages');
                    semanticMessages.innerHTML = '<div class="text-center text-gray-500 text-sm">Nova sessão criada. Digite sua primeira mensagem...</div>';
                    
                    // Atualizar interface
                    document.getElementById('current-semantic-session-name').textContent = sessionName;
                    document.getElementById('current-semantic-session-info').classList.remove('hidden');
                    
                    // Recarregar lista de sessões
                    await loadSessionsForSemanticSelector();
                    
                    showToast(`✅ Sessão "${sessionName}" criada`, 'success');
                } else {
                    showToast('❌ Erro ao criar sessão', 'error');
                }
            } catch (error) {
                console.error('Erro ao criar sessão:', error);
                showToast('❌ Erro ao criar sessão', 'error');
            }
        }
        
        async function loadSessionMessages(sessionId) {
            try {
                const response = await fetch(`/api/sessions/${sessionId}`);
                const result = await response.json();
                
                if (result.success && result.session) {
                    const session = result.session;
                    
                    // Atualizar sessão atual
                    currentSessionId = sessionId;
                    const sessionName = session.name || `Sessão ${sessionId.substring(0, 8)}...`;
                    

                    
                    // Limpar chat atual
                    const chatMessages = document.getElementById('chat-messages');
                    chatMessages.innerHTML = '';
                    
                    // Carregar mensagens da sessão
                    if (session.messages && session.messages.length > 0) {
                        session.messages.forEach(message => {
                            addChatMessage(message.role, message.content, {
                                sources: message.sources || [],
                                fromHistory: true
                            });
                        });
                    } else {
                        addChatMessage('system', 'Sessão carregada. Você pode continuar a conversa.', {
                            fromHistory: true
                        });
                    }
                    
                    showToast(`✅ Sessão "${sessionName}" carregada`, 'success');
                } else {
                    showToast('❌ Erro ao carregar sessão', 'error');
                }
            } catch (error) {
                console.error('Erro ao carregar mensagens da sessão:', error);
                showToast('❌ Erro ao carregar sessão', 'error');
            }
        }
        
        // Event listeners para o seletor de sessões
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🚀 DOM carregado! Verificando elementos do seletor...');
            
            // Verificar se os elementos existem
            const semanticSessionSelect = document.getElementById('semantic-session-select');
            const refreshSemanticSessionsBtn = document.getElementById('refresh-semantic-sessions-btn');
            
            console.log('🔍 Elemento semantic-session-select encontrado:', !!semanticSessionSelect);
            console.log('🔍 Elemento refresh-semantic-sessions-btn encontrado:', !!refreshSemanticSessionsBtn);
            

            
            if (semanticSessionSelect) {
                semanticSessionSelect.addEventListener('change', handleSemanticSessionSelection);
            }
            
            if (refreshSemanticSessionsBtn) {
                refreshSemanticSessionsBtn.addEventListener('click', loadSessionsForSemanticSelector);
            }
            

            
            // Carregar sessões se estiver na aba de semantic
            if (document.getElementById('semantic-content') && !document.getElementById('semantic-content').classList.contains('hidden')) {
                console.log('🚀 Carregando sessões na inicialização para aba semantic');
                loadSessionsForSemanticSelector();
            }
            

        });
        
        async function sendMessage() {
            const message = chatInput.value.trim();
            if (!message || isProcessing) return;
            
            // Limpar resultados anteriores
            clearSearchResults();
            
            // Add user message
            addChatMessage('user', message);
            
            // Clear input
            chatInput.value = '';
            
            // Send via WebSocket
            isProcessing = true;
            updateSendButton();
            
            // Obter o threshold de similaridade (0.0 a 1.0)
            const similarityThreshold = parseFloat(document.getElementById('similarity-threshold').value) / 100;
            
            socket.emit('chat_message', {
                message: message,
                session_id: null, // Busca por similaridade não precisa de sessão
                collection_name: document.getElementById('chat-collection-select').value,
                similarity_threshold: similarityThreshold
            });
        }
        
        async function sendSemanticMessage() {
            const message = semanticInput.value.trim();
            if (!message || isProcessing) return;
            
            // Verificar se há uma sessão ativa
            if (!currentSessionId) {
                showToast('⚠️ Selecione uma sessão ou escolha "Nova sessão"', 'warning');
                return;
            }
            
            // Verificar se pelo menos um modelo foi selecionado
            const selectedModels = getSelectedSemanticModels();
            
            if (selectedModels.length === 0) {
                showToast('Selecione pelo menos um modelo de IA', 'warning');
                return;
            }
            
            // Verificar se pelo menos uma collection foi selecionada
            const selectedCollections = getSelectedSemanticCollections();
            
            if (selectedCollections.length === 0) {
                showToast('Selecione pelo menos uma collection do modelo ativo', 'warning');
                return;
            }
            
            // Add user message
            addSemanticMessage('user', message);
            
            // Clear input
            semanticInput.value = '';
            
            // Send via HTTP request
            isProcessing = true;
            updateSemanticButton();
            
            try {
                const response = await fetch('/api/semantic-search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question: message,
                        session_id: currentSessionId,
                        collection_names: selectedCollections,
                        models: {
                            openai: selectedModels.includes('openai'),
                            gemini: selectedModels.includes('gemini')
                        }
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Exibir respostas lado a lado
                    displaySemanticResults(result.responses);
                } else {
                    addSemanticMessage('error', `Erro: ${result.error}`);
                }
            } catch (error) {
                addSemanticMessage('error', `Erro de conexão: ${error.message}`);
            } finally {
                isProcessing = false;
                updateSemanticButton();
            }
        }
        
        function clearSearchResults() {
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                // Manter apenas a mensagem inicial
                chatMessages.innerHTML = '<div class="text-center text-gray-500 text-sm">Inicie uma busca por similaridade fazendo uma consulta...</div>';
            }
        }
        
        function clearSemanticResults() {
            const semanticMessages = document.getElementById('semantic-messages');
            if (semanticMessages) {
                // Manter apenas a mensagem inicial
                                        semanticMessages.innerHTML = '<div class="text-center text-gray-500 text-sm">Faça uma pergunta para o chat multi-agente...</div>';
            }
        }
        
        function updateSendButton() {
            const sendBtn = document.getElementById('send-message-btn');
            if (sendBtn) {
                if (isProcessing) {
                    sendBtn.disabled = true;
                    sendBtn.textContent = '⏳ Processando...';
                    sendBtn.className = 'bg-gray-400 text-white px-4 py-2 rounded-md cursor-not-allowed';
                } else {
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'Enviar';
                    sendBtn.className = 'bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700';
                }
            }
        }
        
        function updateSemanticButton() {
            const sendBtn = document.getElementById('send-semantic-btn');
            if (sendBtn) {
                if (isProcessing) {
                    sendBtn.disabled = true;
                    sendBtn.textContent = '⏳ Processando...';
                    sendBtn.className = 'bg-gray-400 text-white px-4 py-2 rounded-md cursor-not-allowed self-end';
                } else {
                    sendBtn.disabled = false;
                    sendBtn.textContent = 'Enviar';
                    sendBtn.className = 'bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700 self-end';
                }
            }
        }
        
        function addSemanticMessage(role, content) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message mb-4';
            
            if (role === 'user') {
                messageDiv.innerHTML = `
                    <div class="flex justify-end mb-6">
                        <div class="flex items-end space-x-2">
                            <div class="max-w-lg px-4 py-3 rounded-2xl bg-gradient-to-r from-purple-600 to-purple-700 text-white shadow-lg">
                                <div class="text-sm leading-relaxed">${content}</div>
                            </div>
                            <div class="w-8 h-8 bg-purple-100 rounded-full flex items-center justify-center flex-shrink-0">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#7c3aed" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                                    <circle cx="12" cy="7" r="4"/>
                                </svg>
                            </div>
                        </div>
                    </div>
                `;
            } else if (role === 'assistant') {
                messageDiv.innerHTML = `
                    <div class="flex justify-start mb-6">
                        <div class="flex items-start space-x-3 max-w-4xl">
                            <div class="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#1e40af" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="3"/>
                                    <path d="M12 1v6m0 6v6"/>
                                    <path d="m1 12 6 0m6 0 6 0"/>
                                </svg>
                            </div>
                            <div class="bg-white rounded-2xl px-4 py-3 border border-gray-200 shadow-sm">
                                <div class="text-sm leading-relaxed whitespace-pre-wrap">${content}</div>
                            </div>
                        </div>
                    </div>
                `;
            } else if (role === 'error') {
                messageDiv.innerHTML = `
                    <div class="flex justify-center mb-6">
                        <div class="max-w-lg px-4 py-3 rounded-2xl bg-red-50 border border-red-200 text-red-800 shadow-sm">
                            <div class="flex items-center space-x-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"/>
                                    <line x1="15" y1="9" x2="9" y2="15"/>
                                    <line x1="9" y1="9" x2="15" y2="15"/>
                                </svg>
                                <span class="text-sm font-medium">Erro:</span>
                            </div>
                            <div class="text-sm mt-1">${content}</div>
                        </div>
                    </div>
                `;
            }
            
            semanticMessages.appendChild(messageDiv);
            semanticMessages.scrollTop = semanticMessages.scrollHeight;
        }
        
        function displaySemanticResults(responses) {
            const resultsDiv = document.createElement('div');
            resultsDiv.className = 'chat-message mb-6';
            
            let resultsContent = '';
            
            // Resposta do OpenAI
            if (responses.openai) {
                resultsContent += `
                    <div class="flex justify-start mb-6">
                        <div class="flex items-start space-x-3 max-w-4xl">
                            <div class="w-8 h-8 bg-gradient-to-r from-blue-500 to-blue-600 rounded-full flex items-center justify-center flex-shrink-0 shadow-lg">
                                <span class="text-white font-bold text-sm">O</span>
                            </div>
                            <div class="flex-1">
                                <div class="bg-white rounded-2xl border border-gray-200 shadow-sm p-4">
                                    <div class="flex items-center space-x-2 mb-3">
                                        <h4 class="font-semibold text-gray-900">OpenAI GPT</h4>
                                        <span class="px-2 py-1 bg-blue-100 text-blue-700 text-xs rounded-full">AI</span>
                                    </div>
                                    <div class="prose prose-sm max-w-none text-gray-700 leading-relaxed">
                                        ${marked.parse(responses.openai)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Resposta do Gemini
            if (responses.gemini) {
                resultsContent += `
                    <div class="flex justify-start mb-6">
                        <div class="flex items-start space-x-3 max-w-4xl">
                            <div class="w-8 h-8 bg-gradient-to-r from-green-500 to-green-600 rounded-full flex items-center justify-center flex-shrink-0 shadow-lg">
                                <span class="text-white font-bold text-sm">G</span>
                            </div>
                            <div class="flex-1">
                                <div class="bg-white rounded-2xl border border-gray-200 shadow-sm p-4">
                                    <div class="flex items-center space-x-2 mb-3">
                                        <h4 class="font-semibold text-gray-900">Google Gemini</h4>
                                        <span class="px-2 py-1 bg-green-100 text-green-700 text-xs rounded-full">AI</span>
                                    </div>
                                    <div class="prose prose-sm max-w-none text-gray-700 leading-relaxed">
                                        ${marked.parse(responses.gemini)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            resultsDiv.innerHTML = resultsContent;
            semanticMessages.appendChild(resultsDiv);
            
            // Highlight code blocks
            resultsDiv.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Scroll to bottom
            semanticMessages.scrollTop = semanticMessages.scrollHeight;
        }
        
        function addChatMessage(role, content, metadata = null) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
            
            const isUser = role === 'user';
            const isError = role === 'error';
            
            if (isUser) {
                // Mensagem do usuário (consulta)
                messageDiv.innerHTML = `
                    <div class="flex justify-end">
                        <div class="max-w-xs lg:max-w-md px-4 py-2 rounded-lg bg-blue-600 text-white">
                            <div class="font-medium">🔍 Consulta:</div>
                            <div>${content}</div>
                        </div>
                    </div>
                `;
            } else if (role === 'assistant' && metadata && metadata.sources) {
                // Resultados de busca por similaridade - substituir todo o conteúdo
                const sources = metadata.sources;
                const similarityThreshold = metadata.similarity_threshold || 0;
                
                let resultsContent = `
                    <div class="w-full">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-lg font-semibold text-gray-900">📊 Resultados da Busca</h3>
                            <div class="text-sm text-gray-600">
                                Similaridade mínima: <span class="font-medium text-blue-600">${(similarityThreshold * 100).toFixed(0)}%</span>
                            </div>
                        </div>
                        <div class="text-sm text-gray-600 mb-4">
                            <p>🔍 <strong>Similaridade baseada em cálculo de cosseno</strong> entre o vetor da consulta e os vetores dos chunks de documentos.</p>
                        </div>
                `;
                
                if (sources.length === 0) {
                    resultsContent += `
                        <div class="text-center py-8 text-gray-500">
                            <div class="text-2xl mb-2">🔍</div>
                            <div>Nenhum documento encontrado com similaridade ≥ ${(similarityThreshold * 100).toFixed(0)}%</div>
                        </div>
                    `;
                } else {
                    resultsContent += `<div class="space-y-4">`;
                    
                    sources.forEach((source, index) => {
                        const similarityPercent = (source.similarity_percentage || source.score * 100).toFixed(1);
                        const fileName = source.file_name || 'Documento desconhecido';
                        const content = source.content || 'Conteúdo não disponível';
                        const collectionName = source.source_collection || 'Collection desconhecida';
                        const chunkNumber = source.chunk_number || (index + 1);
                        
                        resultsContent += `
                            <div class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50">
                                <div class="flex items-center justify-between mb-2">
                                    <div class="flex items-center space-x-3">
                                        <div class="font-medium text-gray-900">📄 ${fileName}</div>
                                        <div class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded-full">
                                            📁 ${collectionName}
                                        </div>
                                        <div class="text-xs bg-green-100 text-green-800 px-2 py-1 rounded-full">
                                            #${chunkNumber}
                                        </div>
                                    </div>
                                    <div class="text-sm">
                                        <span class="font-medium text-blue-600">${similarityPercent}%</span>
                                        <span class="text-gray-500">similaridade</span>
                                    </div>
                                </div>
                                <div class="text-sm text-gray-700 bg-gray-50 p-3 rounded border-l-4 border-blue-500">
                                    <div class="font-medium mb-1">Chunk encontrado:</div>
                                    <div class="text-gray-600">${content.substring(0, 300)}${content.length > 300 ? '...' : ''}</div>
                                </div>
                            </div>
                        `;
                    });
                    
                    resultsContent += `</div>`;
                }
                
                resultsContent += `</div>`;
                
                messageDiv.innerHTML = resultsContent;
            } else {
                // Mensagem de erro ou resposta simples
                let messageContent = `<div class="markdown-content">${marked.parse(content)}</div>`;
                
                messageDiv.innerHTML = `
                    <div class="flex ${isError ? 'justify-start' : 'justify-start'}">
                        <div class="max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                            isError ? 'bg-red-100 text-red-800' : 'bg-gray-100 text-gray-900'
                        }">
                            ${messageContent}
                        </div>
                    </div>
                `;
            }
            
            if (role === 'assistant') {
                // Para respostas do sistema, substituir todo o conteúdo
                chatMessages.innerHTML = '';
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = 0; // Scroll para o topo
            } else {
                // Para mensagens do usuário, apenas adicionar
                chatMessages.appendChild(messageDiv);
            }
            
            // Highlight code blocks
            messageDiv.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        }
        
        function updateSendButton() {
            sendMessageBtn.disabled = isProcessing;
            sendMessageBtn.textContent = isProcessing ? 'Enviando...' : 'Enviar';
        }
        
        function updateVectorizationStatus(status, message) {
            const statusDiv = document.getElementById('vectorization-status');
            
            // Se status e message estiverem vazios, limpar o status
            if (!status && !message) {
                statusDiv.innerHTML = '';
                return;
            }
            
            const icon = status === 'success' ? 'bg-green-500' : 
                        status === 'error' ? 'bg-red-500' : 
                        status === 'processing' ? 'bg-yellow-500' : 'bg-gray-400';
            
            statusDiv.innerHTML = `
                <div class="flex items-center space-x-2">
                    <div class="w-2 h-2 ${icon} rounded-full"></div>
                    <span class="text-sm text-gray-600">${message}</span>
                </div>
            `;
        }
        
        function displayQAResults(qaContent) {
            if (!qaContent) {
                showToast('Nenhum Q&A foi gerado', 'warning');
                return;
            }
            
            // Store Q&A content globally
            window.currentQAContent = qaContent;
            
            // Parse Q&A content
            const qaPairs = parseQAContent(qaContent);
            
            // Display in formatted view
            const qaList = document.getElementById('qa-list');
            const qaResults = document.getElementById('qa-results');
            
            qaList.innerHTML = '';
            
            qaPairs.forEach((pair, index) => {
                const qaDiv = document.createElement('div');
                qaDiv.className = 'bg-white border border-gray-200 rounded-lg p-4 shadow-sm';
                qaDiv.innerHTML = `
                    <div class="mb-3">
                        <h4 class="font-medium text-gray-900 flex items-center">
                            <span class="bg-blue-100 text-blue-800 text-xs font-medium px-2 py-1 rounded mr-2">Q${index + 1}</span>
                            Pergunta ${index + 1}
                        </h4>
                        <div class="text-gray-700 mt-1 pl-4 border-l-2 border-blue-200">${pair.question}</div>
                    </div>
                    <div>
                        <h4 class="font-medium text-gray-900 flex items-center">
                            <span class="bg-green-100 text-green-800 text-xs font-medium px-2 py-1 rounded mr-2">R${index + 1}</span>
                            Resposta ${index + 1}
                        </h4>
                        <div class="text-gray-700 mt-1 pl-4 border-l-2 border-green-200">${pair.answer}</div>
                    </div>
                `;
                qaList.appendChild(qaDiv);
            });
            
            // Display raw markdown
            const qaMarkdownContent = document.getElementById('qa-markdown-content');
            qaMarkdownContent.value = qaContent;
            
            qaResults.classList.remove('hidden');
            
            // Setup buttons
            setupDownloadButton(qaContent);
            setupTabHandlers();
            setupCopyButton();
            setupEmbeddingsButton();
        }
        
        function parseQAContent(qaContent) {
            const qaPairs = [];
            const pattern = /\*\*Pergunta (\d+):\*\*(.*?)(?=\*\*Resposta \1:\*\*|\*\*Pergunta \d+:\*\*|\Z)/gs;
            
            let match;
            while ((match = pattern.exec(qaContent)) !== null) {
                const questionNumber = match[1];
                const questionText = match[2].trim();
                
                // Find corresponding answer
                const answerPattern = new RegExp(`\\*\\*Resposta ${questionNumber}:\\*\\*(.*?)(?=\\*\\*Pergunta \\d+:\\*\\*|\\Z)`, 's');
                const answerMatch = qaContent.match(answerPattern);
                const answerText = answerMatch ? answerMatch[1].trim() : '';
                
                if (questionText && answerText) {
                    qaPairs.push({
                        question: questionText,
                        answer: answerText
                    });
                }
            }
            
            return qaPairs;
        }
        
        function setupDownloadButton(qaContent) {
            const downloadBtn = document.getElementById('download-qa-btn');
            if (downloadBtn) {
                downloadBtn.onclick = () => {
                    const blob = new Blob([qaContent], { type: 'text/markdown' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `qas_gerados_${new Date().toISOString().split('T')[0]}.md`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                };
            }
        }
        
        function showQaProgress(message, progress = 0) {
            const qaProgress = document.getElementById('qa-progress');
            const qaProgressBar = document.getElementById('qa-progress-bar');
            const progressStatus = document.getElementById('progress-status');
            const progressDetails = document.getElementById('progress-details');
            
            if (qaProgress && progressStatus && progressDetails) {
                progressStatus.textContent = 'Processando...';
                progressDetails.textContent = `${message} (${progress}%)`;
                qaProgress.classList.remove('hidden');
                
                // Atualizar barra de progresso se existe
                if (qaProgressBar) {
                    qaProgressBar.style.width = `${progress}%`;
                }
            }
        }

        function showVectorizeProgress(message, progress = 0) {
            const vectorizeProgress = document.getElementById('qa-vectorize-progress');
            const vectorizeProgressBar = document.getElementById('qa-vectorize-progress-bar');
            const progressStatus = document.getElementById('vectorize-progress-status');
            const progressDetails = document.getElementById('vectorize-progress-details');
            
            if (vectorizeProgress && progressStatus && progressDetails) {
                progressStatus.textContent = 'Vetorizando...';
                progressDetails.textContent = `${message} (${progress}%)`;
                vectorizeProgress.classList.remove('hidden');
                
                // Atualizar barra de progresso se existe
                if (vectorizeProgressBar) {
                    vectorizeProgressBar.style.width = `${progress}%`;
                }
            }
        }
        
        function hideQaProgress() {
            const qaProgress = document.getElementById('qa-progress');
            const qaProgressBar = document.getElementById('qa-progress-bar');
            
            if (qaProgress) {
                qaProgress.classList.add('hidden');
            }
            
            // Reset da barra de progresso
            if (qaProgressBar) {
                qaProgressBar.style.width = '0%';
            }
        }

        function hideVectorizeProgress() {
            const vectorizeProgress = document.getElementById('qa-vectorize-progress');
            const vectorizeProgressBar = document.getElementById('qa-vectorize-progress-bar');
            
            if (vectorizeProgress) {
                vectorizeProgress.classList.add('hidden');
            }
            
            // Reset da barra de progresso
            if (vectorizeProgressBar) {
                vectorizeProgressBar.style.width = '0%';
            }
        }
        
        async function loadDocumentInfo(documentName) {
            try {
                console.log('🔍 DEBUG [LOAD_DOC_INFO] Iniciando loadDocumentInfo:', documentName);
                
                // Obter a collection selecionada no editor
                const collectionSelect = document.getElementById('editor-collection-select');
                if (!collectionSelect.value) {
                    console.warn('❌ DEBUG [LOAD_DOC_INFO] Nenhuma collection selecionada para carregar informações do documento');
                    return;
                }
                
                const collection = collectionSelect.value;
                const url = `/api/collections/${collection}/content?document=${encodeURIComponent(documentName)}`;
                
                console.log('📡 DEBUG [LOAD_DOC_INFO] Fazendo requisição:', {
                    collection: collection,
                    documentName: documentName,
                    encodedDocumentName: encodeURIComponent(documentName),
                    url: url
                });
                
                const response = await fetch(url);
                console.log('📡 DEBUG [LOAD_DOC_INFO] Resposta recebida:', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok
                });
                
                const result = await response.json();
                console.log('📄 DEBUG [LOAD_DOC_INFO] Resultado JSON:', result);
                
                if (result.success && result.content) {
                    const content = result.content;
                    const words = content.split(/\s+/);
                    const uniqueWords = new Set(words);
                    
                    console.log('✅ DEBUG [LOAD_DOC_INFO] Processando conteúdo:', {
                        contentLength: content.length,
                        wordsCount: words.length,
                        uniqueWordsCount: uniqueWords.size
                    });
                    
                    document.getElementById('char-count').textContent = content.length.toLocaleString('pt-BR');
                    document.getElementById('word-count').textContent = words.length.toLocaleString('pt-BR');
                    document.getElementById('unique-words').textContent = uniqueWords.size.toLocaleString('pt-BR');
                    document.getElementById('avg-word-length').textContent = 
                        (words.reduce((sum, word) => sum + word.length, 0) / words.length).toFixed(1);
                    
                    document.getElementById('document-info').classList.remove('hidden');
                    console.log('✅ DEBUG [LOAD_DOC_INFO] Document info exibido com sucesso');
                } else {
                    console.error('❌ DEBUG [LOAD_DOC_INFO] Falha no resultado:', result);
                    if (result.error) {
                        showToast(`Erro ao carregar documento: ${result.error}`, 'error');
                    }
                }
            } catch (error) {
                console.error('❌ DEBUG [LOAD_DOC_INFO] Erro ao carregar informações do documento:', error);
                showToast('Erro ao carregar informações do documento', 'error');
            }
        }
        
        function hideDocumentInfo() {
            document.getElementById('document-info').classList.add('hidden');
        }
        
        function setupTabHandlers() {
            const tabButtons = document.querySelectorAll('.qa-tab-btn');
            const tabContents = document.querySelectorAll('.qa-tab-content');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const targetTab = button.getAttribute('data-tab');
                    
                    // Remove active classes from all tabs
                    tabButtons.forEach(btn => {
                        btn.classList.remove('border-indigo-500', 'text-indigo-600');
                        btn.classList.add('border-transparent', 'text-gray-500');
                    });
                    
                    // Add active classes to clicked tab
                    button.classList.remove('border-transparent', 'text-gray-500');
                    button.classList.add('border-indigo-500', 'text-indigo-600');
                    
                    // Hide all content panels
                    tabContents.forEach(content => {
                        content.classList.add('hidden');
                    });
                    
                    // Show target content panel
                    document.getElementById(`qa-content-${targetTab}`).classList.remove('hidden');
                });
            });
        }
        
        function setupCopyButton() {
            const copyBtn = document.getElementById('copy-markdown-btn');
            if (copyBtn) {
                copyBtn.addEventListener('click', () => {
                    const markdownContent = document.getElementById('qa-markdown-content');
                    if (markdownContent) {
                        markdownContent.select();
                        navigator.clipboard.writeText(markdownContent.value).then(() => {
                            showToast('Markdown copiado para a área de transferência!', 'success');
                            copyBtn.textContent = '✅ Copiado';
                            setTimeout(() => {
                                copyBtn.textContent = '📋 Copiar';
                            }, 2000);
                        }).catch(() => {
                            showToast('Erro ao copiar markdown', 'error');
                        });
                    }
                });
            }
        }
        
        function setupEmbeddingsButton() {
            const embeddingsBtn = document.getElementById('create-embeddings-btn');
            if (embeddingsBtn) {
                embeddingsBtn.addEventListener('click', async () => {
                    if (!window.currentQAContent) {
                        showToast('Nenhum Q&A disponível para criar embeddings', 'warning');
                        return;
                    }
                    
                    const collectionSelect = document.getElementById('editor-collection-select');
                    if (!collectionSelect.value) {
                        showToast('Selecione uma collection primeiro', 'warning');
                        return;
                    }
                    
                    // Mostrar modal para criar embeddings
                    showEmbeddingsModal();
                });
            }
        }
        
        function showEmbeddingsModal() {
            // Criar modal dinâmico
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50';
            modal.innerHTML = `
                <div class="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white">
                    <div class="mt-3">
                        <h3 class="text-lg font-medium text-gray-900 mb-4">🔗 Criar Embeddings dos Q&As</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Nome da Nova Collection:</label>
                                <input type="text" id="embeddings-collection-name" class="w-full border border-gray-300 rounded-md px-3 py-2" placeholder="qa_collection_embeddings">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-1">Modelo de Embedding:</label>
                                <select id="embeddings-model-select" class="w-full border border-gray-300 rounded-md px-3 py-2">
                                    <option value="text-embedding-3-small">OpenAI text-embedding-3-small</option>
                                    <option value="text-embedding-3-large">OpenAI text-embedding-3-large</option>
                                </select>
                            </div>
                        </div>
                        <div class="flex justify-end space-x-3 mt-6">
                            <button id="cancel-embeddings" class="bg-gray-300 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-400">
                                Cancelar
                            </button>
                            <button id="create-embeddings" class="bg-purple-600 text-white px-4 py-2 rounded-md hover:bg-purple-700">
                                Criar Embeddings
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Event handlers para o modal
            document.getElementById('cancel-embeddings').addEventListener('click', () => {
                document.body.removeChild(modal);
            });
            
            document.getElementById('create-embeddings').addEventListener('click', () => {
                createEmbeddingsFromQA();
                document.body.removeChild(modal);
            });
            
            // Fechar modal clicando fora
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }
        
        async function createEmbeddingsFromQA() {
            const collectionName = document.getElementById('embeddings-collection-name').value || 'qa_collection_embeddings';
            const embeddingModel = document.getElementById('embeddings-model-select').value;
            
            if (!window.currentQAContent) {
                showToast('Nenhum Q&A disponível', 'error');
                return;
            }
            
            try {
                showToast('Criando embeddings dos Q&As...', 'info');
                
                // Preparar dados para o endpoint
                const qaData = {
                    qa_content: window.currentQAContent,
                    collection_name: collectionName,
                    embedding_model: embeddingModel
                };
                
                // Chamar endpoint para criar embeddings (será implementado no backend)
                const response = await fetch('/api/create-qa-embeddings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(qaData)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showToast(`✅ Embeddings criados com sucesso na collection "${collectionName}"`, 'success');
                    // Recarregar collections para mostrar a nova
                    await loadCollections();
                } else {
                    throw new Error(result.error || 'Erro ao criar embeddings');
                }
                
            } catch (error) {
                showToast(`❌ Erro ao criar embeddings: ${error.message}`, 'error');
                console.error('Erro ao criar embeddings:', error);
            }
        }
        
        async function loadSessions() {
            try {
                const response = await fetch('/api/sessions');
                const result = await response.json();
                
                const sessionsList = document.getElementById('sessions-list');
                sessionsList.innerHTML = '';
                
                if (!result.sessions || result.sessions.length === 0) {
                    sessionsList.innerHTML = `
                        <div class="text-center py-8 text-gray-500">
                            <i data-lucide="message-circle" class="w-12 h-12 mx-auto mb-4 text-gray-300"></i>
                            <p>Nenhuma sessão encontrada</p>
                            <p class="text-sm">Crie uma nova sessão para começar a conversar</p>
                        </div>
                    `;
                    lucide.createIcons();
                    return;
                }
                
                result.sessions.forEach(session => {
                    const sessionDiv = document.createElement('div');
                    sessionDiv.className = 'border border-gray-200 rounded-lg p-4 cursor-pointer hover:bg-gray-50 transition-colors';
                    
                    // Formatar data
                    const lastActivity = session.last_activity ? new Date(session.last_activity).toLocaleString('pt-BR') : 'Desconhecido';
                    const sessionName = session.name || `Sessão ${session.session_id.substring(0, 8)}...`;
                    
                    sessionDiv.innerHTML = `
                        <div class="flex justify-between items-start">
                            <div class="flex-1">
                                <div class="flex items-center gap-2 mb-2">
                                    <h4 class="font-medium text-gray-900">${sessionName}</h4>
                                    <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded-full">
                                        ${session.message_count} mensagens
                                    </span>
                                </div>
                                <p class="text-sm text-gray-600">Última atividade: ${lastActivity}</p>
                            </div>
                            <div class="flex items-center gap-2">
                                <button class="load-session-btn p-2 text-blue-600 hover:bg-blue-50 rounded-full" 
                                        data-session-id="${session.session_id}" title="Carregar sessão">
                                    <i data-lucide="arrow-right" class="w-4 h-4"></i>
                                </button>
                                <button class="delete-session-btn p-2 text-red-600 hover:bg-red-50 rounded-full" 
                                        data-session-id="${session.session_id}" title="Deletar sessão">
                                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                    `;
                    
                    sessionsList.appendChild(sessionDiv);
                });
                
                // Adicionar event listeners
                document.querySelectorAll('.load-session-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        const sessionId = btn.dataset.sessionId;
                        loadSessionMessages(sessionId);
                    };
                });
                
                document.querySelectorAll('.delete-session-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        const sessionId = btn.dataset.sessionId;
                        deleteSession(sessionId);
                    };
                });
                
                // Reinitialize icons
                lucide.createIcons();
            } catch (error) {
                console.error('Erro ao carregar sessões:', error);
                showToast('❌ Erro ao carregar sessões', 'error');
            }
        }
        
        async function loadSessionMessages(sessionId) {
            try {
                const response = await fetch(`/api/sessions/${sessionId}`);
                const result = await response.json();
                
                if (result.success && result.session) {
                    const session = result.session;
                    
                    // Atualizar sessão atual
                    currentSessionId = sessionId;
                    const sessionName = session.name || `Sessão ${sessionId.substring(0, 8)}...`;
                    

                    
                    // Limpar chat atual
                    const chatMessages = document.getElementById('chat-messages');
                    chatMessages.innerHTML = '';
                    
                    // Carregar mensagens da sessão
                    if (session.messages && session.messages.length > 0) {
                        session.messages.forEach(message => {
                            addChatMessage(message.role, message.content, {
                                sources: message.sources || [],
                                fromHistory: true
                            });
                        });
                    } else {
                        addChatMessage('system', 'Sessão carregada. Você pode continuar a conversa.', {
                            fromHistory: true
                        });
                    }
                    
                    // Mudar para aba de chat
                    showContent('chat');
                    
                    showToast(`✅ Sessão "${sessionName}" carregada com sucesso`, 'success');
                } else {
                    showToast('❌ Erro ao carregar sessão', 'error');
                }
            } catch (error) {
                console.error('Erro ao carregar mensagens da sessão:', error);
                showToast('❌ Erro ao carregar sessão', 'error');
            }
        }
        
        async function deleteSession(sessionId) {
            if (!confirm('Tem certeza que deseja deletar esta sessão? Esta ação não pode ser desfeita.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/sessions/${sessionId}`, {
                    method: 'DELETE'
                });
                const result = await response.json();
                
                if (result.success) {
                    showToast('✅ Sessão deletada com sucesso', 'success');
                    
                    // Se a sessão deletada era a atual, limpar
                    if (currentSessionId === sessionId) {
                        currentSessionId = null;
                        

                        
                        const chatMessages = document.getElementById('chat-messages');
                        chatMessages.innerHTML = '';
                    }
                    
                    // Recarregar lista de sessões
                    await loadSessions();
                } else {
                    showToast('❌ Erro ao deletar sessão', 'error');
                }
            } catch (error) {
                console.error('Erro ao deletar sessão:', error);
                showToast('❌ Erro ao deletar sessão', 'error');
            }
        }
        
        // Document Management
        
        async function loadDocuments() {
            console.log('🔍 Carregando todos os documentos...');
            try {
                const response = await fetch('/api/storage-info');
                console.log('📡 Response documentos:', response.status);
                const result = await response.json();
                console.log('📁 Dados documentos:', result);
                
                if (result.success && result.documents) {
                    documents = result.documents;
                    console.log('✅ Documentos carregados:', documents.length);
                    console.log('🗄️ Tipo de storage:', result.storage_type);
                    // Não atualizar automaticamente - esperar seleção de collection
                } else {
                    console.error('❌ Falha ao carregar documentos:', result);
                    documents = [];
                }
            } catch (error) {
                console.error('❌ Erro ao carregar documentos:', error);
                documents = [];
            }
        }
        
        async function loadDocumentsForCollection(collectionName) {
            console.log('🔍 Carregando documentos para collection:', collectionName);
            
            if (!documents || documents.length === 0) {
                console.log('⚠️ Nenhum documento carregado ainda - tentando recarregar...');
                await loadDocuments();
                
                if (!documents || documents.length === 0) {
                    console.log('❌ Ainda não há documentos após reload');
                    updateDocumentSelect([]);
                    return;
                }
            }
            
            console.log('📦 Total de documentos disponíveis:', documents.length);
            console.log('📦 Primeiros 5 documentos completos:', documents.slice(0, 5));
            
            // Mostrar estrutura de alguns documentos para entender o formato
            documents.slice(0, 5).forEach((doc, i) => {
                console.log(`📄 Documento ${i + 1}:`, doc);
                console.log(`   name: ${doc.name}`);
                console.log(`   path: ${doc.path}`);
                console.log(`   object_name: ${doc.object_name}`);
            });
            
            // Filtrar documentos da collection específica - match inteligente
            console.log('🔍 Procurando por collection:', collectionName);
            
            const collectionDocuments = documents.filter(doc => {
                const docPath = doc.name || doc.path || doc;
                
                // Verificar múltiplas formas de match (case-insensitive e fuzzy)
                const collectionLower = collectionName.toLowerCase().replace('_', '');
                const pathLower = docPath.toLowerCase();
                
                const matchPatterns = [
                    // Match exato
                    pathLower.includes(collectionName.toLowerCase() + '/'),
                    // Match com case diferentes
                    pathLower.includes(collectionLower + '/'),
                    // Match sem underscores (teste_openai -> testeopenai)
                    pathLower.includes(collectionLower.replace('_', '') + '/'),
                    // Match com sufixos (_real, etc)
                    pathLower.includes(collectionLower + '_real/'),
                    pathLower.includes(collectionLower + '_test/'),
                    // Match começando com o nome
                    pathLower.startsWith(collectionLower + '/'),
                    pathLower.startsWith(collectionLower.replace('_', '') + '/'),
                    // Match contendo o nome base
                    pathLower.includes('/' + collectionLower + '/'),
                    pathLower.includes(collectionLower),
                    // Match específicos que vemos nos dados
                    (collectionName === 'teste_openai' && (pathLower.includes('testeopenai/') || pathLower.includes('teste_openai_real/'))),
                    (collectionName === 'Teste_gemini' && pathLower.includes('teste_gemini/'))
                ];
                
                const matches = matchPatterns.some(pattern => pattern);
                
                if (matches) {
                    console.log('✅ MATCH encontrado!', docPath);
                }
                
                return matches;
            });
            
            console.log('📁 Documentos da collection encontrados:', collectionDocuments.length);
            console.log('📁 Paths da collection:', collectionDocuments.map(d => d.name || d.path || d));
            
            // Filtrar documentos originais de forma mais flexível
            const originalDocuments = collectionDocuments.filter(doc => {
                const docPath = doc.name || doc.path || doc;
                
                // Verificar se NÃO é convertido
                const isNotConverted = !docPath.includes('/converted/') && !docPath.endsWith('.md');
                
                // Verificar extensões válidas
                const validExtensions = ['.pdf', '.docx', '.doc', '.txt', '.pptx', '.xlsx'];
                const hasValidExtension = validExtensions.some(ext => docPath.toLowerCase().endsWith(ext));
                
                console.log('📄 Analisando:', docPath);
                console.log('  - Não convertido:', isNotConverted);
                console.log('  - Extensão válida:', hasValidExtension);
                
                return isNotConverted && hasValidExtension;
            });
            
            console.log('📄 Documentos originais filtrados:', originalDocuments.length);
            console.log('📄 Documentos originais finais:', originalDocuments.map(d => d.name || d.path || d));
            
            // Se não encontrou nenhum original, mostrar todos da collection para debug
            if (originalDocuments.length === 0 && collectionDocuments.length > 0) {
                console.log('⚠️ Nenhum original encontrado, mostrando todos da collection para debug');
                updateDocumentSelect(collectionDocuments);
            } else {
                updateDocumentSelect(originalDocuments);
            }
        }
        
        function updateDocumentSelect(documentsToShow = null) {
            console.log('🔄 Atualizando select de documentos...');
            
            const docsToUse = documentsToShow || [];
            console.log('📁 Documentos a mostrar:', docsToUse.length);
            console.log('📁 Lista de documentos:', docsToUse.map(d => d.name || d.path || d));
            
            const documentSelect = document.getElementById('editor-document-select');
            if (!documentSelect) {
                console.error('❌ Elemento select não encontrado!');
                return;
            }
            
            // Limpar opções existentes
            documentSelect.innerHTML = '<option value="">Selecione um documento...</option>';
            
            if (docsToUse && docsToUse.length > 0) {
                docsToUse.forEach((doc, index) => {
                    // Usar o name/file_name que são os campos disponíveis no backend
                    const docValue = doc.name || doc.file_name || doc.path || doc;
                    const docName = doc.name || doc.file_name || (doc.path ? doc.path.split('/').pop() : doc);
                    
                    console.log(`🔍 DEBUG [SELECT_OPTION] Doc ${index + 1}:`, {
                        name: doc.name,
                        file_name: doc.file_name,
                        minio_path: doc.minio_path,
                        chosen_value: docValue,
                        chosen_name: docName
                    });
                    
                    const option = document.createElement('option');
                    option.value = docValue;
                    
                    // Mostrar tipo de arquivo e tamanho se disponível
                    let displayName = docName;
                    if (doc.file_size && doc.file_size > 0) {
                        const sizeKB = Math.round(doc.file_size / 1024);
                        displayName += ` (${sizeKB} KB)`;
                    } else if (doc.size) {
                        const sizeKB = Math.round(doc.size / 1024);
                        displayName += ` (${sizeKB} KB)`;
                    }
                    
                    // Adicionar indicador se o documento foi processado
                    if (doc.minio_processed_path) {
                        displayName += ' ✅';
                    }
                    
                    option.textContent = displayName;
                    option.title = `${docName}\nCaminho: ${docValue}\nProcessado: ${doc.minio_processed_path ? 'Sim' : 'Não'}`; // Tooltip com informações completas
                    
                    documentSelect.appendChild(option);
                    
                    console.log(`📄 ${index + 1}. Adicionado: ${docName} (valor: ${docValue})`);
                });
                
                console.log('✅ Select atualizado com', docsToUse.length, 'documentos');
            } else {
                // Mostrar mensagem informativa
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'Nenhum documento encontrado para esta collection';
                option.disabled = true;
                option.style.color = '#6B7280';
                documentSelect.appendChild(option);
                
                console.log('⚠️ Nenhum documento encontrado - adicionada mensagem informativa');
            }
            
            // Disparar evento change para atualizar interface
            documentSelect.dispatchEvent(new Event('change'));
        }
        
        // Collection Management
        
        async function loadCollections() {
            console.log('🔍 Carregando collections...');
            try {
                const response = await fetch('/api/collections');
                console.log('📡 Response collections:', response.status);
                const result = await response.json();
                console.log('📁 Dados collections:', result);
                
                if (result.success && result.collections) {
                    collections = result.collections;
                    console.log('✅ Collections carregadas:', collections.length);
                    updateCollectionSelect();
                    updateCollectionsList();
                    updateModelFilter();
                } else {
                    console.error('❌ Falha ao carregar collections:', result);
                    collections = [];
                    updateCollectionSelect();
                    updateCollectionsList();
                    updateModelFilter();
                }
            } catch (error) {
                console.error('❌ Erro ao carregar collections:', error);
                collections = [];
                updateCollectionSelect();
                updateCollectionsList();
            }
        }
        
        async function loadEmbeddingModels() {
            try {
                const response = await fetch('/api/embedding-models');
                const result = await response.json();
                
                if (result.success) {
                    embeddingModels = result.models;
                    updateEmbeddingModelSelect();
                }
            } catch (error) {
                console.error('Erro ao carregar modelos de embedding:', error);
            }
        }
        
        function updateCollectionSelect() {
            console.log('🔄 Atualizando selects de collection...');
            console.log('📁 Collections disponíveis:', collections);
            
            const selects = [
                document.getElementById('upload-collection-select'),
                document.getElementById('editor-collection-select'),
                document.getElementById('chat-collection-select')
            ];
            
            selects.forEach(select => {
                if (select) {
                    console.log(`🔧 Atualizando collection select: ${select.id}`);
                    select.innerHTML = '<option value="">Selecione uma collection...</option>';
                    
                    if (collections && collections.length > 0) {
                        collections.forEach(collection => {
                            const option = document.createElement('option');
                            option.value = collection.name;
                            option.textContent = `${collection.name} (${collection.embedding_model})`;
                            select.appendChild(option);
                            console.log(`  ➕ Collection adicionada: ${collection.name}`);
                        });
                    } else {
                        const option = document.createElement('option');
                        option.value = '';
                        option.textContent = 'Nenhuma collection disponível';
                        option.disabled = true;
                        select.appendChild(option);
                        console.log('❌ Nenhuma collection encontrada');
                    }
                }
            });
            
            // Atualizar checkboxes organizados por modelo para chat multi-agente
            updateModelBasedCollections();
        }
        
        function updateModelBasedCollections() {
            console.log('🔧 Atualizando collections organizadas por modelo...');
            
            if (!collections || collections.length === 0) {
                // Se não há collections, mostrar mensagem nos dois containers
                const openaiContainer = document.getElementById('openai-collections');
                const geminiContainer = document.getElementById('gemini-collections');
                
                if (openaiContainer) {
                    openaiContainer.innerHTML = '<div class="text-xs text-blue-500">Nenhuma collection OpenAI</div>';
                }
                if (geminiContainer) {
                    geminiContainer.innerHTML = '<div class="text-xs text-green-500">Nenhuma collection Gemini</div>';
                }
                return;
            }
            
            // Separar collections por modelo
            const openaiCollections = collections.filter(collection => 
                collection.embedding_model === 'openai' || 
                (collection.model_config && collection.model_config.provider === 'openai')
            );
            
            const geminiCollections = collections.filter(collection => 
                collection.embedding_model === 'gemini' || 
                (collection.model_config && collection.model_config.provider === 'gemini')
            );
            
            console.log('📁 OpenAI Collections:', openaiCollections);
            console.log('📁 Gemini Collections:', geminiCollections);
            
            // Atualizar collections OpenAI
            updateModelCollections('openai-collections', openaiCollections, 'openai', 'blue');
            
            // Atualizar collections Gemini  
            updateModelCollections('gemini-collections', geminiCollections, 'gemini', 'green');
            
            // Configurar eventos para controle de dependência
            setupModelDependencyControls();
        }
        
        function updateModelCollections(containerId, collectionsForModel, modelId, colorTheme) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            if (collectionsForModel.length === 0) {
                container.innerHTML = `<div class="text-xs text-${colorTheme}-500">Nenhuma collection ${modelId.toUpperCase()}</div>`;
                return;
            }
            
            container.innerHTML = '';
            
            collectionsForModel.forEach((collection, index) => {
                const label = document.createElement('label');
                label.className = 'flex items-center space-x-1 cursor-pointer hover:bg-gray-100 p-1 rounded text-xs border border-gray-200';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `${modelId}-collection-${index}`;
                checkbox.value = collection.name;
                checkbox.className = `rounded border-gray-300 text-${colorTheme}-600 focus:ring-${colorTheme}-500 h-3 w-3 collection-checkbox`;
                checkbox.checked = true;
                checkbox.dataset.model = modelId;
                
                const span = document.createElement('span');
                span.className = `text-xs text-${colorTheme}-700 whitespace-nowrap`;
                span.textContent = collection.name;
                span.title = collection.name;
                
                label.appendChild(checkbox);
                label.appendChild(span);
                container.appendChild(label);
            });
        }
        
        function setupModelDependencyControls() {
            console.log('🔧 Configurando controles de dependência modelo-collection...');
            
            // Event listeners para checkboxes dos modelos
            const openaiModelCheckbox = document.getElementById('openai-model-checkbox');
            const geminiModelCheckbox = document.getElementById('gemini-model-checkbox');
            
            if (openaiModelCheckbox) {
                openaiModelCheckbox.addEventListener('change', function() {
                    toggleModelCollections('openai', this.checked);
                });
            }
            
            if (geminiModelCheckbox) {
                geminiModelCheckbox.addEventListener('change', function() {
                    toggleModelCollections('gemini', this.checked);
                });
            }
        }
        
        function toggleModelCollections(modelId, isEnabled) {
            console.log(`🔧 ${isEnabled ? 'Habilitando' : 'Desabilitando'} collections do modelo ${modelId}`);
            
            // Buscar todas as collections deste modelo
            const modelCollections = document.querySelectorAll(`input.collection-checkbox[data-model="${modelId}"]`);
            
            modelCollections.forEach(checkbox => {
                checkbox.disabled = !isEnabled;
                if (!isEnabled) {
                    checkbox.checked = false; // Desmarcar se modelo desabilitado
                } else {
                    checkbox.checked = true; // Marcar se modelo habilitado
                }
                
                // Aplicar estilo visual
                const label = checkbox.closest('label');
                if (label) {
                    if (isEnabled) {
                        label.classList.remove('opacity-50', 'cursor-not-allowed');
                        label.classList.add('cursor-pointer');
                    } else {
                        label.classList.add('opacity-50', 'cursor-not-allowed');
                        label.classList.remove('cursor-pointer');
                    }
                }
            });
        }
        
        function toggleAllModelsAndCollections() {
            const openaiModelCheckbox = document.getElementById('openai-model-checkbox');
            const geminiModelCheckbox = document.getElementById('gemini-model-checkbox');
            
            // Verificar se todos estão selecionados
            const allSelected = openaiModelCheckbox?.checked && geminiModelCheckbox?.checked;
            
            // Alternar estado
            const newState = !allSelected;
            
            if (openaiModelCheckbox) {
                openaiModelCheckbox.checked = newState;
                toggleModelCollections('openai', newState);
            }
            
            if (geminiModelCheckbox) {
                geminiModelCheckbox.checked = newState;
                toggleModelCollections('gemini', newState);
            }
        }
        
        function toggleAllSemanticCollections() {
            const checkboxes = document.querySelectorAll('#semantic-collection-checkboxes input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
        }
        
        function toggleAllSemanticModels() {
            const checkboxes = document.querySelectorAll('#semantic-models-checkboxes input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
        }
        
        function showAllCollections() {
            // Implementar modal ou expandir lista se necessário
            console.log('Mostrar todas as collections...');
        }
        
        function getSelectedSemanticCollections() {
            // Buscar collections selecionadas em ambos os modelos
            const checkboxes = document.querySelectorAll('.collection-checkbox:checked');
            return Array.from(checkboxes).map(checkbox => checkbox.value);
        }
        
        function getSelectedSemanticModels() {
            const models = [];
            
            const openaiModelCheckbox = document.getElementById('openai-model-checkbox');
            const geminiModelCheckbox = document.getElementById('gemini-model-checkbox');
            
            if (openaiModelCheckbox?.checked) {
                models.push('openai');
            }
            
            if (geminiModelCheckbox?.checked) {
                models.push('gemini');
            }
            
            return models;
        }

        
        async function toggleDocuments(collectionName) {
            const documentsContainer = document.getElementById(`documents-${collectionName}`);
            const toggleButton = documentsContainer.parentElement.querySelector('button[onclick*="toggleDocuments"]');
            const toggleText = toggleButton.querySelector('.toggle-text');
            const isVisible = !documentsContainer.classList.contains('hidden');
            
            if (isVisible) {
                // Esconder documentos
                documentsContainer.classList.add('hidden');
                toggleText.textContent = 'Ver documentos';
                return;
            }
            
            // Mostrar documentos
            documentsContainer.classList.remove('hidden');
            toggleText.textContent = 'Ocultar documentos';
            
            try {
                const response = await fetch(`/api/collections/${collectionName}/documents`);
                const result = await response.json();
                
                if (result.success) {
                    if (result.documents.length === 0) {
                        documentsContainer.innerHTML = `
                            <div class="text-center py-4">
                                <i data-lucide="file-x" class="w-8 h-8 text-gray-400 mx-auto mb-2"></i>
                                <p class="text-sm text-gray-600">Nenhum documento encontrado nesta collection</p>
                                <p class="text-xs text-gray-500 mt-1">Faça upload de um documento para começar</p>
                            </div>
                        `;
                    } else {
                        let documentsHtml = `
                            <div class="mb-3">
                                <h5 class="text-sm font-medium text-gray-700 mb-2">Documentos (${result.documents.length})</h5>
                            </div>
                            <div class="space-y-4 max-h-96 overflow-y-auto">
                        `;
                        
                        result.documents.forEach(doc => {
                            console.log('🔍 Processando documento:', doc);
                            const filename = doc.file_name || doc.name || 'Documento sem nome';
                            const uploadDate = doc.created_at ? new Date(doc.created_at).toLocaleString('pt-BR') : 'Data desconhecida';
                            const totalChunks = doc.total_chunks || 0;
                            const chunks = doc.chunks || [];
                            
                            console.log('📄 Filename:', filename);
                            console.log('📅 Upload date:', uploadDate);
                            console.log('📊 Total chunks:', totalChunks);
                            
                            // Determinar ícone baseado no tipo de arquivo
                            let fileIcon = 'file-text';
                            if (filename.toLowerCase().endsWith('.pdf')) fileIcon = 'file';
                            else if (filename.toLowerCase().endsWith('.docx')) fileIcon = 'file-text';
                            else if (filename.toLowerCase().endsWith('.txt')) fileIcon = 'file-text';
                            else if (filename.toLowerCase().endsWith('.md')) fileIcon = 'file-text';
                            
                            documentsHtml += `
                                <div class="border border-gray-200 rounded-lg p-4 bg-white">
                                    <div class="flex items-center justify-between mb-3">
                                        <div class="flex items-center space-x-3">
                                            <i data-lucide="${fileIcon}" class="w-5 h-5 text-blue-500 flex-shrink-0"></i>
                                            <div>
                                                <h4 class="text-sm font-medium text-gray-900">${filename}</h4>
                                                <p class="text-xs text-gray-500">Processado em: ${uploadDate}</p>
                                            </div>
                                        </div>
                                        <div class="flex items-center space-x-2">
                                            <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">${totalChunks} chunks</span>
                                        </div>
                                    </div>
                                    
                                    ${chunks.length > 0 ? `
                                        <div class="space-y-2">
                                            <h5 class="text-xs font-medium text-gray-700 mb-2">Chunks do documento:</h5>
                                            <div class="max-h-64 overflow-y-auto space-y-2">
                                                ${chunks.map(chunk => `
                                                    <div class="bg-gray-50 rounded p-3 border-l-4 border-blue-500">
                                                        <div class="flex items-center justify-between mb-2">
                                                            <span class="text-xs font-medium text-gray-700">Chunk ${chunk.chunk_index + 1}</span>
                                                            <span class="text-xs text-gray-500">${chunk.chunk_size} caracteres</span>
                                                        </div>
                                                        <p class="text-xs text-gray-700 leading-relaxed">${chunk.content.substring(0, 200)}${chunk.content.length > 200 ? '...' : ''}</p>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        </div>
                                    ` : `
                                        <div class="text-center py-2">
                                            <p class="text-xs text-gray-500">Nenhum chunk encontrado</p>
                                        </div>
                                    `}
                                </div>
                            `;
                        });
                        
                        documentsHtml += '</div>';
                        documentsContainer.innerHTML = documentsHtml;
                    }
                } else {
                    documentsContainer.innerHTML = `
                        <div class="text-center py-4">
                            <i data-lucide="alert-circle" class="w-8 h-8 text-red-400 mx-auto mb-2"></i>
                            <p class="text-sm text-red-600">Erro ao carregar documentos: ${result.error}</p>
                        </div>
                    `;
                }
            } catch (error) {
                documentsContainer.innerHTML = `
                    <div class="text-center py-4">
                        <i data-lucide="alert-circle" class="w-8 h-8 text-red-400 mx-auto mb-2"></i>
                        <p class="text-sm text-red-600">Erro ao carregar documentos: ${error.message}</p>
                    </div>
                `;
            }
            
            // Reinitialize icons
            lucide.createIcons();
        }
        
        function updateCollectionsList() {
            const container = document.getElementById('collections-list');
            container.innerHTML = '';
            
            collections.forEach(collection => {
                
                const div = document.createElement('div');
                div.className = 'border border-gray-200 rounded-lg p-4';
                
                div.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div class="flex-1">
                            <div class="flex items-center space-x-3">
                                <h4 class="font-medium text-gray-900">${collection.name}</h4>
                                <button onclick="toggleDocuments('${collection.name}')" 
                                        class="text-blue-600 hover:text-blue-800 text-sm flex items-center space-x-1 transition-colors">
                                    <i data-lucide="file-text" class="w-4 h-4"></i>
                                    <span class="toggle-text">Ver documentos</span>
                                </button>
                            </div>
                            <p class="text-sm text-gray-600 mt-1">${collection.description || 'Sem descrição'}</p>
                            <div class="text-xs text-gray-500 mt-2">
                                <span class="bg-blue-100 text-blue-800 px-2 py-1 rounded">${collection.embedding_model}</span>
                                <span class="bg-green-100 text-green-800 px-2 py-1 rounded ml-2">${collection.document_count || 0} docs</span>
                                <span class="bg-purple-100 text-purple-800 px-2 py-1 rounded ml-2">${collection.chunk_count || 0} chunks</span>
                            </div>
                        </div>
                        <button onclick="deleteCollection('${collection.name}')" class="text-red-600 hover:text-red-800 text-sm">
                            Deletar
                        </button>
                    </div>
                    <div id="documents-${collection.name}" class="hidden mt-4 border-t pt-4">
                        <div class="flex items-center justify-center py-4">
                            <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
                            <span class="ml-2 text-sm text-gray-600">Carregando documentos...</span>
                        </div>
                    </div>
                `;
                
                container.appendChild(div);
            });
            
            // Reinitialize icons
            lucide.createIcons();
        }
        

        
        function updateEmbeddingModelSelect() {
            const selects = [
                document.getElementById('embedding-model-select'),
                document.getElementById('collection-embedding-model-select')
            ];
            
            selects.forEach(select => {
                if (select) {
                    select.innerHTML = '<option value="">Selecione um modelo...</option>';
                    
                    embeddingModels.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = `${model.name} (${model.dimension}d)`;
                        select.appendChild(option);
                    });
                }
            });
        }
        
        function updateModelFilter() {
            const modelFilter = document.getElementById('model-filter');
            if (modelFilter) {
                modelFilter.innerHTML = '<option value="">Todos os modelos</option>';
                
                // Obter modelos únicos das collections
                const uniqueModels = [...new Set(collections.map(c => c.embedding_model))];
                
                uniqueModels.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelFilter.appendChild(option);
                });
            }
        }
        
        // Modal functions
        function showCollectionModal() {
            document.getElementById('collection-modal').classList.remove('hidden');
        }
        
        function hideCollectionModal() {
            document.getElementById('collection-modal').classList.add('hidden');
            document.getElementById('collection-name-input').value = '';
            document.getElementById('collection-description-input').value = '';
            document.getElementById('collection-embedding-model-select').value = '';
            document.getElementById('collection-model-info').classList.add('hidden');
        }
        

        
        async function createCollection() {
            const name = document.getElementById('collection-name-input').value.trim();
            const description = document.getElementById('collection-description-input').value.trim();
            const embeddingModel = document.getElementById('collection-embedding-model-select').value;
            
            if (!name || !embeddingModel) {
                showToast('Nome da collection e modelo de embedding são obrigatórios', 'warning');
                return;
            }
            
            try {
                const response = await fetch('/api/collections', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        name: name,
                        description: description,
                        embedding_model: embeddingModel
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    hideCollectionModal();
                    await loadCollections();
                    showToast('Collection criada com sucesso!', 'success');
                } else {
                    showToast(`Erro ao criar collection: ${result.error}`, 'error');
                }
            } catch (error) {
                showToast(`Erro ao criar collection: ${error.message}`, 'error');
            }
        }
        
        async function deleteCollection(collectionName) {
            if (!confirm(`Tem certeza que deseja deletar a collection "${collectionName}"?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/collections/${collectionName}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    await loadCollections();
                    updateCollectionsList(); // Atualizar a listagem
                    showToast('Collection deletada com sucesso!', 'success');
                } else {
                    showToast(`Erro ao deletar collection: ${result.error}`, 'error');
                }
            } catch (error) {
                showToast(`Erro ao deletar collection: ${error.message}`, 'error');
            }
        }
        
        function filterCollectionsByModel(selectedModel) {
            const container = document.getElementById('collections-list');
            const collectionElements = container.querySelectorAll('.border');
            
            collectionElements.forEach(element => {
                const collectionName = element.querySelector('h4').textContent;
                const collection = collections.find(c => c.name === collectionName);
                
                if (selectedModel === '' || collection.embedding_model === selectedModel) {
                    element.style.display = 'block';
                } else {
                    element.style.display = 'none';
                }
            });
        }
        

        
        const newCollectionBtn = document.getElementById('new-collection-btn');
        if (newCollectionBtn) newCollectionBtn.addEventListener('click', showCollectionModal);
        
        const cancelCollectionBtn = document.getElementById('cancel-collection-btn');
        if (cancelCollectionBtn) cancelCollectionBtn.addEventListener('click', hideCollectionModal);
        
        const createCollectionBtn = document.getElementById('create-collection-btn');
        if (createCollectionBtn) createCollectionBtn.addEventListener('click', createCollection);
        
        // Filtro por modelo
        const modelFilter = document.getElementById('model-filter');
        if (modelFilter) {
            modelFilter.addEventListener('change', (e) => {
                const selectedModel = e.target.value;
                filterCollectionsByModel(selectedModel);
            });
        }
        
        const embeddingModelSelect = document.getElementById('embedding-model-select');
        if (embeddingModelSelect) {
            embeddingModelSelect.addEventListener('change', (e) => {
                const modelId = e.target.value;
                const model = embeddingModels.find(m => m.id === modelId);
                
                const modelInfo = document.getElementById('model-info');
                if (model) {
                    const modelName = document.getElementById('model-name');
                    const modelDimension = document.getElementById('model-dimension');
                    const modelProvider = document.getElementById('model-provider');
                    
                    if (modelName) modelName.textContent = model.name;
                    if (modelDimension) modelDimension.textContent = model.dimension;
                    if (modelProvider) modelProvider.textContent = model.provider;
                    if (modelInfo) modelInfo.classList.remove('hidden');
                } else {
                    if (modelInfo) modelInfo.classList.add('hidden');
                }
            });
        }
        

        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 DOM carregado! Iniciando aplicação...');
            
            try {
                console.log('📁 Chamando initializeUpload...');
                initializeUpload();
                console.log('✅ initializeUpload concluído');
            } catch (error) {
                console.error('❌ Erro em initializeUpload:', error);
            }
            

            

            
            try {
                console.log('📁 Chamando loadCollections...');
                loadCollections();
                console.log('✅ loadCollections chamado');
            } catch (error) {
                console.error('❌ Erro em loadCollections:', error);
            }
            
            try {
                console.log('📁 Chamando loadDocuments...');
                loadDocuments();
                console.log('✅ loadDocuments chamado');
            } catch (error) {
                console.error('❌ Erro em loadDocuments:', error);
            }
            
            // Outros métodos simplificados
            try {
                loadSessions();
                loadEmbeddingModels();
                setupNewQAFeatures();
                setupSimilarityControl();
                setupSemanticSearch();
            } catch (error) {
                console.error('❌ Erro em outras funções:', error);
            }
        });
        
        // ============= NOVAS FUNCIONALIDADES Q&A =============
        
        function setupSimilarityControl() {
            console.log('🎛️ Configurando controle de similaridade');
            
            const similaritySlider = document.getElementById('similarity-threshold');
            const similarityValue = document.getElementById('similarity-value');
            
            if (similaritySlider && similarityValue) {
                // Atualizar valor exibido quando o slider muda
                similaritySlider.addEventListener('input', (e) => {
                    const value = e.target.value;
                    similarityValue.textContent = `${value}%`;
                    
                    // Atualizar o gradiente da barra
                    const percentage = (value / 100) * 100;
                    e.target.style.background = `linear-gradient(to right, #3b82f6 0%, #3b82f6 ${percentage}%, #e5e7eb ${percentage}%)`;
                });
                
                // Inicializar o gradiente
                similaritySlider.style.background = `linear-gradient(to right, #3b82f6 0%, #3b82f6 0%, #e5e7eb 0%)`;
            }
        }
        
        function setupNewQAFeatures() {
            console.log('🚀 Configurando novas funcionalidades Q&A');
            
            // Configurar dropdown da collection de destino
            setupQACollectionSelect();
            
            // Configurar botão de vetorização final
            setupVectorizeFinalButton();
            
            // Configurar botão de salvar alterações no markdown
            setupSaveMarkdownButton();
            
            // Configurar sincronização entre dropdowns
            setupCollectionSync();
        }
        
        function setupQACollectionSelect() {
            const qaCollectionSelect = document.getElementById('qa-collection-select');
            if (qaCollectionSelect) {
                qaCollectionSelect.addEventListener('change', () => {
                    updateVectorizationUI();
                });
            }
            
            // Configurar botão de refresh
            const refreshCollectionsBtn = document.getElementById('refresh-collections-btn');
            if (refreshCollectionsBtn) {
                refreshCollectionsBtn.addEventListener('click', async () => {
                    console.log('🔄 Atualizando collections...');
                    refreshCollectionsBtn.disabled = true;
                    refreshCollectionsBtn.textContent = '⏳ Atualizando...';
                    
                    try {
                        await populateQACollectionSelect();
                        showToast('Collections atualizadas com sucesso!', 'success');
                    } catch (error) {
                        console.error('Erro ao atualizar collections:', error);
                        showToast('Erro ao atualizar collections', 'error');
                    } finally {
                        refreshCollectionsBtn.disabled = false;
                        refreshCollectionsBtn.textContent = '🔄 Atualizar';
                    }
                });
            }
        }
        
        function setupVectorizeFinalButton() {
            const vectorizeFinalBtn = document.getElementById('vectorize-final-btn');
            if (vectorizeFinalBtn) {
                vectorizeFinalBtn.addEventListener('click', async () => {
                    const qaCollectionSelect = document.getElementById('qa-collection-select');
                    
                    if (!qaCollectionSelect.value) {
                        showToast('Selecione uma collection de destino primeiro', 'warning');
                        return;
                    }
                    
                    if (!window.currentQAContent) {
                        showToast('Nenhum conteúdo Q&A disponível para vetorizar', 'warning');
                        return;
                    }
                    
                    // Verificar se houve alterações no markdown
                    const markdownTextarea = document.getElementById('qa-markdown-content');
                    const currentMarkdown = markdownTextarea.value;
                    
                    vectorizeFinalBtn.disabled = true;
                    vectorizeFinalBtn.textContent = 'Vetorizando...';
                    showVectorizeProgress('Iniciando vetorização final...', 0);
                    
                    try {
                        const response = await fetch('/api/qa-vectorize', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                qa_content: currentMarkdown || window.currentQAContent,
                                collection_name: qaCollectionSelect.value
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            hideVectorizeProgress();
                            showToast(`✅ ${result.qa_count} Q&As vetorizados com sucesso na collection "${qaCollectionSelect.value}"`, 'success');
                            
                            // Recarregar collections
                            await loadCollections();
                            
                            // Resetar interface
                            resetQAInterface();
                        } else {
                            throw new Error(result.error);
                        }
                    } catch (error) {
                        hideVectorizeProgress();
                        showToast(`Erro ao vetorizar Q&As: ${error.message}`, 'error');
                    } finally {
                        vectorizeFinalBtn.disabled = false;
                        vectorizeFinalBtn.textContent = '📊 Vetorizar Q&As';
                    }
                });
            }
        }
        
        function setupSaveMarkdownButton() {
            const saveMarkdownBtn = document.getElementById('save-markdown-btn');
            if (saveMarkdownBtn) {
                saveMarkdownBtn.addEventListener('click', () => {
                    const markdownTextarea = document.getElementById('qa-markdown-content');
                    const currentContent = markdownTextarea.value;
                    
                    // Atualizar o conteúdo global
                    window.currentQAContent = currentContent;
                    
                    // Atualizar preview formatado
                    displayQAResults(currentContent);
                    
                    showToast('Alterações salvas no preview!', 'success');
                    
                    // Feedback visual temporário
                    saveMarkdownBtn.textContent = '✅ Salvo';
                    setTimeout(() => {
                        saveMarkdownBtn.textContent = '💾 Salvar Alterações';
                    }, 2000);
                });
            }
        }
        
        function setupCollectionSync() {
            const editorCollectionSelect = document.getElementById('editor-collection-select');
            const qaCollectionSelect = document.getElementById('qa-collection-select');
            
            if (editorCollectionSelect && qaCollectionSelect) {
                // Sincronizar options quando o dropdown de origem muda
                editorCollectionSelect.addEventListener('change', async () => {
                    await populateQACollectionSelect();
                });
            }
        }
        
        async function populateQACollectionSelect() {
            console.log('🔄 Populando seletor de collections destino...');
            const qaCollectionSelect = document.getElementById('qa-collection-select');
            if (!qaCollectionSelect) {
                console.error('❌ qa-collection-select não encontrado!');
                return;
            }
            
            try {
                const response = await fetch('/api/collections');
                const result = await response.json();
                
                // Limpar options existentes
                qaCollectionSelect.innerHTML = '<option value="">Selecione a collection destino...</option>';
                
                if (result.success && result.collections) {
                    console.log(`✅ ${result.collections.length} collections carregadas para destino`);
                    result.collections.forEach(collection => {
                        const option = document.createElement('option');
                        option.value = collection.name;
                        option.textContent = `${collection.name} (${collection.count || 0} docs)`;
                        qaCollectionSelect.appendChild(option);
                    });
                    
                    // Adicionar opção para criar nova collection
                    const newOption = document.createElement('option');
                    newOption.value = 'NEW_COLLECTION';
                    newOption.textContent = '+ Criar Nova Collection';
                    qaCollectionSelect.appendChild(newOption);
                } else {
                    console.error('❌ Falha ao carregar collections:', result);
                }
            } catch (error) {
                console.error('❌ Erro ao carregar collections para Q&A:', error);
            }
        }
        
        function updateVectorizationUI() {
            const qaCollectionSelect = document.getElementById('qa-collection-select');
            const vectorizeFinalBtn = document.getElementById('vectorize-final-btn');
            
            if (qaCollectionSelect && vectorizeFinalBtn) {
                const selectedCollection = qaCollectionSelect.value;
                
                if (selectedCollection && selectedCollection !== 'NEW_COLLECTION') {
                    console.log('✅ Collection selecionada:', selectedCollection);
                    vectorizeFinalBtn.disabled = !window.currentQAContent;
                } else if (selectedCollection === 'NEW_COLLECTION') {
                    console.log('✅ Nova collection será criada');
                    vectorizeFinalBtn.disabled = !window.currentQAContent;
                } else {
                    console.log('⚠️ Nenhuma collection selecionada');
                    vectorizeFinalBtn.disabled = true;
                }
                
                // Atualizar texto do botão baseado no estado
                if (window.currentQAContent && selectedCollection) {
                    vectorizeFinalBtn.textContent = '📊 Vetorizar Q&As';
                    vectorizeFinalBtn.classList.remove('disabled:bg-gray-400');
                } else {
                    vectorizeFinalBtn.textContent = '📊 Vetorizar Q&As';
                    vectorizeFinalBtn.classList.add('disabled:bg-gray-400');
                }
            }
        }
        
        function resetQAInterface() {
            // Limpar conteúdo armazenado
            window.currentQAContent = null;
            
            // Ocultar seção de resultados
            const qaResults = document.getElementById('qa-results');
            if (qaResults) {
                qaResults.classList.add('hidden');
            }
            
            // Resetar dropdowns
            const documentSelect = document.getElementById('editor-document-select');
            const qaCollectionSelect = document.getElementById('qa-collection-select');
            
            if (documentSelect) documentSelect.value = '';
            if (qaCollectionSelect) qaCollectionSelect.value = '';
            
            // Atualizar UI de vetorização
            updateVectorizationUI();
        }
        
        // Sobrescrever a função displayQAResults para melhor formatação
        function displayQAResults(qaContent) {
            const qaResults = document.getElementById('qa-results');
            const qaList = document.getElementById('qa-list');
            const qaMarkdownContent = document.getElementById('qa-markdown-content');
            
            if (!qaResults || !qaList || !qaMarkdownContent) return;
            
            // Mostrar seção de resultados
            qaResults.classList.remove('hidden');
            
            // Preencher markdown editável
            qaMarkdownContent.value = qaContent;
            
            // Processar e exibir preview formatado
            const qaBlocks = qaContent.split(/\*\*Pergunta \d+:\*\*/);
            qaList.innerHTML = '';
            
            qaBlocks.forEach((block, index) => {
                if (index === 0 || !block.trim()) return;
                
                const parts = block.split(/\*\*Resposta \d+:\*\*/);
                if (parts.length < 2) return;
                
                const question = parts[0].trim();
                const answer = parts[1].trim();
                
                const qaItem = document.createElement('div');
                qaItem.className = 'border border-gray-200 rounded-lg p-4 bg-white shadow-sm';
                qaItem.innerHTML = `
                    <div class="mb-3">
                        <h4 class="font-semibold text-gray-900 text-sm">📝 Pergunta ${index}:</h4>
                        <p class="text-gray-700 text-sm mt-1">${question}</p>
                    </div>
                    <div>
                        <h4 class="font-semibold text-green-700 text-sm">💡 Resposta ${index}:</h4>
                        <p class="text-gray-700 text-sm mt-1">${answer}</p>
                    </div>
                `;
                qaList.appendChild(qaItem);
            });
            
            // Inicialmente mostrar a aba de preview formatado
            setupTabHandlers();
            
            // Atualizar UI de vetorização
            updateVectorizationUI();
            
            // Popular dropdown de collections de destino se ainda não foi feito
            populateQACollectionSelect();
        }
        
        // Funções auxiliares para teste de charset
        async function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        resolve(e.target.result);
                    } catch (error) {
                        reject(new Error(`Erro ao ler arquivo: ${error.message}`));
                    }
                };
                
                reader.onerror = function() {
                    reject(new Error('Erro ao ler o arquivo'));
                };
                
                // Tentar ler como UTF-8 primeiro
                reader.readAsText(file, 'UTF-8');
            });
        }
        
        function displayCharsetTestResults(diagnosis, recommendation) {
            console.log('📊 Exibindo resultados do teste de charset:', diagnosis);
            
            // Mostrar container de resultados
            charsetTestResults.classList.remove('hidden');
            
            // Determinar classe de status baseada nos problemas encontrados
            const hasProblems = diagnosis.encoding_issues?.length > 0 || 
                               diagnosis.character_analysis?.total_problematic > 0;
            
            const statusClass = hasProblems ? 'bg-yellow-50 border-yellow-200' : 'bg-green-50 border-green-200';
            const statusColor = hasProblems ? 'text-yellow-700' : 'text-green-700';
            const statusIcon = hasProblems ? '⚠️' : '✅';
            
            charsetTestContent.innerHTML = `
                <div class="${statusClass} border rounded-lg p-3 mb-3">
                    <div class="flex items-center space-x-2 mb-2">
                        <span class="text-lg">${statusIcon}</span>
                        <span class="text-sm font-medium ${statusColor}">${recommendation}</span>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-xs">
                    <div class="bg-white rounded-lg p-3 border">
                        <h5 class="font-semibold text-gray-700 mb-2">📊 Estatísticas</h5>
                        <div class="space-y-1">
                            <div><strong>Tamanho original:</strong> ${diagnosis.original_length?.toLocaleString()} caracteres</div>
                            <div><strong>Tamanho sanitizado:</strong> ${diagnosis.sanitized_length?.toLocaleString()} caracteres</div>
                            <div><strong>Encoding original:</strong> ${diagnosis.original_encoding_test || 'N/A'}</div>
                        </div>
                    </div>
                    
                    <div class="bg-white rounded-lg p-3 border">
                        <h5 class="font-semibold text-gray-700 mb-2">🔍 Análise de Caracteres</h5>
                        <div class="space-y-1">
                            <div><strong>Caracteres problemáticos:</strong> ${diagnosis.character_analysis?.total_problematic || 0}</div>
                            <div><strong>Problemas de encoding:</strong> ${diagnosis.encoding_issues?.length || 0}</div>
                            ${diagnosis.character_analysis?.total_problematic > 0 ? 
                                `<div class="text-orange-600"><strong>Ação:</strong> Arquivo será sanitizado automaticamente</div>` : 
                                `<div class="text-green-600"><strong>Status:</strong> Arquivo está limpo</div>`
                            }
                        </div>
                    </div>
                </div>
                
                ${diagnosis.encoding_issues?.length > 0 ? `
                    <div class="bg-red-50 border border-red-200 rounded-lg p-3 mt-3">
                        <h5 class="font-semibold text-red-700 mb-2">❌ Problemas Detectados</h5>
                        <div class="text-xs text-red-600">
                            ${diagnosis.encoding_issues.slice(0, 3).map(issue => `<div>• ${issue}</div>`).join('')}
                            ${diagnosis.encoding_issues.length > 3 ? `<div class="text-red-500">... e mais ${diagnosis.encoding_issues.length - 3} problemas</div>` : ''}
                        </div>
                    </div>
                ` : ''}
                
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mt-3">
                    <div class="flex items-start space-x-2">
                        <span class="text-blue-500">📝</span>
                        <div class="text-xs text-blue-700">
                            <strong>Próximos passos:</strong> 
                            ${hasProblems ? 
                                'O arquivo será automaticamente sanitizado durante o upload para prevenir erros.' : 
                                'O arquivo está pronto para upload sem problemas de charset.'
                            }
                        </div>
                    </div>
                </div>
            `;
        }
        
        // ============= BUSCA SEMÂNTICA POR MODELO =============
        
        function setupSemanticSearch() {
            console.log('📝 Configurando busca semântica por modelo');
            
            // Carregar modelos de embedding
            loadSemanticSearchModels();
            
            // Event listeners
            const searchBtn = document.getElementById('semantic-search-btn');
            const searchInput = document.getElementById('semantic-search-input');
            const debugBtn = document.getElementById('debug-collections-btn');
            const testBtn = document.getElementById('test-search-btn');
            const testGeminiBtn = document.getElementById('test-gemini-btn');
            
            if (searchBtn) {
                searchBtn.addEventListener('click', performSemanticSearch);
            }
            
            if (searchInput) {
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        performSemanticSearch();
                    }
                });
            }
            
            if (debugBtn) {
                debugBtn.addEventListener('click', showDebugInfo);
            }
            
            if (testBtn) {
                testBtn.addEventListener('click', testSemanticSearchWithExample);
            }
            
            if (testGeminiBtn) {
                testGeminiBtn.addEventListener('click', testGeminiModels);
            }
            
            // Configurar controle de similaridade para busca semântica
            setupSemanticSimilarityControl();
        }
        
        async function loadSemanticSearchModels() {
            try {
                const response = await fetch('/api/embedding-models');
                const result = await response.json();
                
                if (result.success) {
                    const modelsContainer = document.getElementById('semantic-search-models');
                    if (modelsContainer) {
                        modelsContainer.innerHTML = '';
                        
                        result.models.forEach(model => {
                            const modelElement = document.createElement('label');
                            modelElement.className = 'inline-flex items-center cursor-pointer';
                            modelElement.innerHTML = `
                                <input type="radio" name="semantic-model" value="${model.id}" class="form-radio text-indigo-600 mr-2">
                                <span class="text-sm font-medium text-gray-700">${model.name}</span>
                                <span class="text-xs text-gray-500 ml-2">(${model.provider})</span>
                            `;
                            modelsContainer.appendChild(modelElement);
                        });
                    }
                }
            } catch (error) {
                console.error('❌ Erro ao carregar modelos:', error);
            }
        }
        
        function setupSemanticSimilarityControl() {
            const similaritySlider = document.getElementById('semantic-similarity-threshold');
            const similarityValue = document.getElementById('semantic-similarity-value');
            
            if (similaritySlider && similarityValue) {
                // Função para atualizar cor do slider baseada no valor
                function updateSliderColor(value) {
                    const min = parseInt(similaritySlider.min);
                    const max = parseInt(similaritySlider.max);
                    const percentage = ((value - min) / (max - min)) * 100;
                    
                    // Gradiente de cinza para azul
                    const grayColor = '#9ca3af';
                    const blueColor = '#3b82f6';
                    
                    similaritySlider.style.background = `linear-gradient(to right, ${blueColor} 0%, ${blueColor} ${percentage}%, ${grayColor} ${percentage}%, ${grayColor} 100%)`;
                }
                
                // Atualizar valor exibido e cor quando o slider muda
                similaritySlider.addEventListener('input', (e) => {
                    const value = e.target.value;
                    similarityValue.textContent = `${value}%`;
                    updateSliderColor(value);
                });
                
                // Definir valor inicial e cor
                similarityValue.textContent = `${similaritySlider.value}%`;
                updateSliderColor(similaritySlider.value);
            }
        }
        
        function getSemanticSimilarityThreshold() {
            const slider = document.getElementById('semantic-similarity-threshold');
            return slider ? parseFloat(slider.value) / 100 : 0.3; // Padrão 30%
        }
        
        async function testGeminiModels() {
            const resultsContainer = document.getElementById('semantic-search-results');
            
            try {
                resultsContainer.innerHTML = '<div class="text-center text-gray-500">🔍 Testando modelos Gemini disponíveis...</div>';
                
                const response = await fetch('/api/debug/gemini-models');
                const data = await response.json();
                
                if (data.success) {
                    displayGeminiModelsDebug(data);
                } else {
                    resultsContainer.innerHTML = `<div class="text-red-600">❌ Erro ao testar Gemini: ${data.error}</div>`;
                }
                
            } catch (error) {
                console.error('❌ Erro ao testar Gemini:', error);
                resultsContainer.innerHTML = `<div class="text-red-600">❌ Erro de conexão: ${error.message}</div>`;
            }
        }
        
        function displayGeminiModelsDebug(data) {
            const resultsContainer = document.getElementById('semantic-search-results');
            
            let html = `
                <div class="space-y-4">
                    <div class="bg-purple-50 rounded-lg p-4 border border-purple-200">
                        <h3 class="text-lg font-semibold text-purple-900 mb-3">🔍 Teste de Modelos Gemini</h3>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <strong>Configuração Atual:</strong> ${data.current_config}
                            </div>
                            <div>
                                <strong>API Key:</strong> ${data.api_key_configured ? '✅ Configurada' : '❌ Não configurada'}
                            </div>
                        </div>
                    </div>
                    
                    <!-- Modelos Disponíveis -->
                    <div class="bg-green-50 rounded-lg p-4 border border-green-200">
                        <h3 class="text-lg font-semibold text-green-900 mb-3">✅ Modelos Funcionando (${data.available_models.length})</h3>
                        <div class="space-y-2">
            `;
            
            if (data.available_models.length > 0) {
                data.available_models.forEach(model => {
                    html += `
                        <div class="bg-white rounded-md p-2 border border-green-200">
                            <span class="font-medium text-green-800">✅ ${model}</span>
                        </div>
                    `;
                });
            } else {
                html += `<div class="text-green-700">Nenhum modelo disponível encontrado</div>`;
            }
            
            html += `
                        </div>
                    </div>
                    
                    <!-- Modelos Indisponíveis -->
                    <div class="bg-red-50 rounded-lg p-4 border border-red-200">
                        <h3 class="text-lg font-semibold text-red-900 mb-3">❌ Modelos com Problema (${data.unavailable_models.length})</h3>
                        <div class="space-y-2">
            `;
            
            if (data.unavailable_models.length > 0) {
                data.unavailable_models.forEach(model => {
                    html += `
                        <div class="bg-white rounded-md p-2 border border-red-200">
                            <span class="font-medium text-red-800">❌ ${model}</span>
                        </div>
                    `;
                });
            } else {
                html += `<div class="text-red-700">Todos os modelos estão funcionando!</div>`;
            }
            
            html += `
                        </div>
                    </div>
                    
                    <!-- Recomendação -->
                    <div class="bg-blue-50 rounded-lg p-4 border border-blue-200">
                        <h3 class="text-lg font-semibold text-blue-900 mb-2">💡 Recomendação</h3>
                        <p class="text-blue-800">
                            ${data.available_models.length > 0 ? 
                                `O sistema tentará usar automaticamente: <strong>${data.available_models[0]}</strong>` :
                                'Nenhum modelo Gemini disponível. Verifique sua API key ou use OpenAI.'
                            }
                        </p>
                    </div>
                </div>
            `;
            
            resultsContainer.innerHTML = html;
        }
        
        async function testSemanticSearchWithExample() {
            const resultsContainer = document.getElementById('semantic-search-results');
            
            try {
                resultsContainer.innerHTML = '<div class="text-center text-gray-500">🧪 Executando teste automático...</div>';
                
                // 1. Selecionar modelo OpenAI automaticamente
                const openaiRadio = document.querySelector('input[name="semantic-model"][value="openai"]');
                if (openaiRadio) {
                    openaiRadio.checked = true;
                } else {
                    resultsContainer.innerHTML = '<div class="text-red-600">❌ Modelo OpenAI não encontrado</div>';
                    return;
                }
                
                // 2. Fazer busca com exemplo
                const testQuery = "localização do condomínio";
                
                console.log('🧪 Iniciando teste com:', testQuery);
                
                const response = await fetch('/api/semantic-search-by-model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: testQuery,
                        model: 'openai',
                        similarity_threshold: getSemanticSimilarityThreshold()
                    })
                });
                
                const result = await response.json();
                console.log('🧪 Resultado do teste:', result);
                
                if (result.success) {
                    displaySemanticSearchResults(result);
                    showToast('✅ Teste executado com sucesso!', 'success');
                } else {
                    resultsContainer.innerHTML = `
                        <div class="space-y-4">
                            <div class="bg-red-50 rounded-lg p-4 border border-red-200">
                                <h3 class="text-lg font-semibold text-red-900 mb-3">❌ Teste Falhou</h3>
                                <div class="text-red-800">${result.error}</div>
                                ${result.debug_info ? `
                                <div class="mt-3 text-sm text-red-700">
                                    <strong>Info de Debug:</strong><br>
                                    <pre class="bg-red-100 p-2 rounded mt-1">${JSON.stringify(result.debug_info, null, 2)}</pre>
                                </div>
                                ` : ''}
                            </div>
                        </div>
                    `;
                    showToast('❌ Teste falhou - veja detalhes', 'error');
                }
                
            } catch (error) {
                console.error('❌ Erro no teste:', error);
                resultsContainer.innerHTML = `<div class="text-red-600">❌ Erro de conexão no teste: ${error.message}</div>`;
                showToast('❌ Erro de conexão no teste', 'error');
            }
        }
        
        async function performSemanticSearch() {
            const searchInput = document.getElementById('semantic-search-input');
            const searchBtn = document.getElementById('semantic-search-btn');
            const resultsContainer = document.getElementById('semantic-search-results');
            
            const query = searchInput.value.trim();
            const selectedModel = document.querySelector('input[name="semantic-model"]:checked');
            
            if (!query) {
                showToast('Digite uma pergunta para buscar', 'warning');
                return;
            }
            
            if (!selectedModel) {
                showToast('Selecione um modelo de IA', 'warning');
                return;
            }
            
            // Loading state
            searchBtn.disabled = true;
            searchBtn.textContent = 'Buscando...';
            resultsContainer.innerHTML = '<div class="text-center text-gray-500">Processando busca semântica...</div>';
            
            try {
                const response = await fetch('/api/semantic-search-by-model', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        query: query,
                        model: selectedModel.value,
                        similarity_threshold: getSemanticSimilarityThreshold()
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    displaySemanticSearchResults(result);
                } else {
                    resultsContainer.innerHTML = `<div class="text-red-600">Erro: ${result.error}</div>`;
                }
                
            } catch (error) {
                console.error('❌ Erro na busca semântica:', error);
                resultsContainer.innerHTML = `<div class="text-red-600">Erro de conexão: ${error.message}</div>`;
            } finally {
                // Reset button
                searchBtn.disabled = false;
                searchBtn.textContent = 'Buscar';
            }
        }
        
        async function showDebugInfo() {
            const resultsContainer = document.getElementById('semantic-search-results');
            
            try {
                resultsContainer.innerHTML = '<div class="text-center text-gray-500">Carregando informações de debug...</div>';
                
                const response = await fetch('/api/debug/collections-by-model');
                const debugData = await response.json();
                
                if (debugData.success) {
                    displayDebugInfo(debugData.debug_info);
                } else {
                    resultsContainer.innerHTML = `<div class="text-red-600">Erro no debug: ${debugData.error}</div>`;
                }
            } catch (error) {
                console.error('❌ Erro ao buscar debug:', error);
                resultsContainer.innerHTML = `<div class="text-red-600">Erro de conexão: ${error.message}</div>`;
            }
        }
        
        function displayDebugInfo(debugInfo) {
            const resultsContainer = document.getElementById('semantic-search-results');
            
            let html = `
                <div class="space-y-6">
                    <div class="bg-blue-50 rounded-lg p-4 border border-blue-200">
                        <h3 class="text-lg font-semibold text-blue-900 mb-3">🔍 Informações de Debug</h3>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <strong>Total de Collections:</strong> ${debugInfo.total_collections}
                            </div>
                            <div>
                                <strong>Modelos Disponíveis:</strong> ${debugInfo.models_available.join(', ')}
                            </div>
                        </div>
                    </div>
                    
                    <!-- Collections por Modelo -->
                    <div class="bg-gray-50 rounded-lg p-4 border">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3">📊 Collections por Modelo</h3>
                        <div class="space-y-3">
            `;
            
            for (const [model, collections] of Object.entries(debugInfo.collections_by_model)) {
                html += `
                    <div class="bg-white rounded-md p-3 border border-gray-200">
                        <div class="flex justify-between items-center mb-2">
                            <strong class="text-gray-800">${model.toUpperCase()}</strong>
                            <span class="text-sm text-gray-600">${collections.length} collections</span>
                        </div>
                        <div class="text-sm text-gray-700">
                            ${collections.length > 0 ? collections.join(', ') : 'Nenhuma collection encontrada'}
                        </div>
                    </div>
                `;
            }
            
            html += `
                        </div>
                    </div>
                    
                    <!-- Detalhes das Collections -->
                    <div class="bg-gray-50 rounded-lg p-4 border">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3">📄 Detalhes das Collections</h3>
                        <div class="space-y-2 max-h-96 overflow-y-auto">
            `;
            
            debugInfo.collections.forEach((collection, index) => {
                const provider = collection.model_config?.provider || 'N/A';
                html += `
                    <div class="bg-white rounded-md p-3 border border-gray-200 text-sm">
                        <div class="font-medium text-gray-800">${collection.name}</div>
                        <div class="text-gray-600 mt-1">
                            <strong>Exists:</strong> ${collection.exists_in_qdrant ? 'Sim' : 'Não'} | 
                            <strong>Model:</strong> ${collection.embedding_model || 'N/A'} | 
                            <strong>Provider:</strong> ${provider} | 
                            <strong>Docs:</strong> ${collection.document_count}
                        </div>
                    </div>
                `;
            });
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            resultsContainer.innerHTML = html;
        }
        
        function displaySemanticSearchResults(result) {
            const resultsContainer = document.getElementById('semantic-search-results');
            
            let html = `
                <div class="space-y-6">
                    <!-- AI Response -->
                    <div class="bg-gradient-to-r from-indigo-50 to-purple-50 rounded-lg p-4 border border-indigo-200">
                        <h3 class="text-lg font-semibold text-indigo-900 mb-3">🤖 Resposta da IA</h3>
                        <div class="text-gray-800 whitespace-pre-wrap">${result.response}</div>
                        <div class="mt-3 text-sm text-indigo-600">
                            <strong>Modelo:</strong> ${result.model_info.name} (${result.model_info.provider})
                        </div>
                        ${result.collections_searched ? `
                        <div class="mt-2 text-sm text-indigo-600">
                            <strong>Collections consultadas:</strong> ${result.collections_searched.join(', ')}
                        </div>
                        ` : ''}
                        ${result.total_chunks_found ? `
                        <div class="mt-1 text-sm text-indigo-600">
                            <strong>Total de chunks encontrados:</strong> ${result.total_chunks_found}
                        </div>
                        ` : ''}
                    </div>
                    
                    <!-- Source Chunks -->
                    <div class="bg-gray-50 rounded-lg p-4 border">
                        <h3 class="text-lg font-semibold text-gray-900 mb-3">📄 Chunks Utilizados (${result.chunks ? result.chunks.length : 0})</h3>
                        <div class="space-y-3">
            `;
            
            if (result.chunks && result.chunks.length > 0) {
                result.chunks.forEach((chunk, index) => {
                    const similarityPercent = (chunk.similarity * 100).toFixed(1);
                    html += `
                        <div class="bg-white rounded-md p-3 border border-gray-200">
                            <div class="flex justify-between items-start mb-2">
                                <div class="text-sm font-medium text-gray-700">
                                    📂 ${chunk.source_collection} - Chunk ${index + 1}
                                </div>
                                <div class="flex items-center space-x-2">
                                    <div class="text-sm text-indigo-600 font-semibold bg-indigo-100 px-2 py-1 rounded">
                                        ${similarityPercent}% similaridade
                                    </div>
                                    ${parseFloat(similarityPercent) < 60 ? 
                                        '<div class="text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded">⚠️ Possível falso positivo</div>' : ''
                                    }
                                </div>
                            </div>
                            <div class="text-sm text-gray-600 mb-2">
                                <strong>📄 Documento:</strong> ${chunk.document_name || chunk.file_name || 'N/A'}
                            </div>
                            <div class="text-sm text-gray-800 bg-gray-50 rounded p-3 border-l-4 border-indigo-300">
                                ${chunk.content || chunk.text || 'Conteúdo não disponível'}
                            </div>
                            ${parseFloat(similarityPercent) < 60 ? `
                            <div class="mt-2 text-xs text-yellow-700 bg-yellow-50 p-2 rounded border border-yellow-200">
                                <strong>⚠️ Análise:</strong> Esta similaridade pode ser um falso positivo. Embeddings vetoriais podem encontrar similaridades entre palavras similares mesmo quando o contexto é completamente diferente (ex: "teoria" em contextos científicos vs. jurídicos).
                            </div>
                            ` : ''}
                        </div>
                    `;
                });
            } else {
                html += `
                    <div class="text-center text-gray-500 py-4">
                        Nenhum chunk foi retornado para esta consulta.
                    </div>
                `;
            }
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            resultsContainer.innerHTML = html;
        }
        
        // Inicializar ícones Lucide (removed due to CSP)
        // lucide.createIcons();
    </script>
</body>
</html> 